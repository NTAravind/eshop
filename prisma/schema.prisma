generator client {
  provider = "prisma-client-js"
  output   = "../app/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

////////////////////
/// ENUMS
////////////////////

enum StoreRole {
  OWNER
  MANAGER
  SUPPORT
}

enum OrderStatus {
  PENDING
  PAID
  COMPLETED
  CANCELLED
  REFUNDED
}

enum PaymentProvider {
  STRIPE
  RAZORPAY
  MANUAL
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum DiscountType {
  PERCENTAGE
  FIXED_AMOUNT
}

enum DiscountScope {
  STORE_WIDE
  CATEGORY
  PRODUCT
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  TRIALING
}

enum BillingCycle {
  MONTHLY
  YEARLY
}

enum PlanType {
  FREE
  BASIC
  PRO
  ENTERPRISE
}

enum NotificationChannel {
  WHATSAPP
  EMAIL
  WEB_PUSH
  MOBILE_PUSH
  IN_APP
}

enum NotificationStatus {
  QUEUED
  SENT
  DELIVERED
  FAILED
}

////////////////////
/// USERS (Auth.js)
////////////////////

model User {
  id               String           @id @default(cuid())
  email            String           @unique
  emailVerified    DateTime?
  name             String?
  phone            String?          // Optional phone number
  image            String?
  isSuperAdmin     Boolean          @default(false)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  billingAddresses BillingAddress[]
  accounts         Account[]
  sessions         Session[]
  stores           StoreStaff[]
  discountUsages   DiscountUsage[]
  ownedAccounts    AccountUser[]
  orders           Order[]
  carts            Cart[]
}

model BillingAddress {
  id         String   @id @default(cuid())
  userId     String
  address1   String
  address2   String?
  city       String
  state      String
  postalCode String
  country    String
  createdAt  DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  orders Order[]

  @@index([userId])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

////////////////////
/// ACCOUNTS (ORGANIZATIONS)
////////////////////

model BillingAccount {
  id        String   @id @default(cuid())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users        AccountUser[]
  stores       Store[]
  subscription AccountSubscription?
  usage        UsageCounter[]
  invoices     Invoice[]
  invitations  AccountInvitation[]
  emailSettings Json? // Global SMTP settings for the account

  @@index([createdAt])
}

model AccountUser {
  id        String   @id @default(cuid())
  accountId String
  userId    String
  role      String   @default("MEMBER")
  createdAt DateTime @default(now())

  account BillingAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  user    User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([accountId, userId])
  @@index([accountId])
  @@index([userId])
}

////////////////////
/// SUBSCRIPTION PLANS
////////////////////

model SubscriptionPlan {
  id          String   @id @default(cuid())
  type        PlanType @unique
  name        String
  description String?

  price       Int
  yearlyPrice Int?

  maxStores              Int?
  maxProducts            Int?
  maxOrdersPerMonth      Int?
  maxStaffMembers        Int?
  maxAPIRequestsPerMonth Int?

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  subscriptions AccountSubscription[]

  @@index([type])
  @@index([isActive])
  
}

////////////////////
/// ACCOUNT SUBSCRIPTIONS
////////////////////

model AccountSubscription {
  id        String             @id @default(cuid())
  accountId String             @unique
  planId    String
  status    SubscriptionStatus @default(ACTIVE)
  billingCycle BillingCycle @default(MONTHLY)

  currentPeriodStart DateTime
  currentPeriodEnd   DateTime

  cancelAtPeriodEnd Boolean @default(false)
  canceledAt        DateTime?

  trialEndsAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  account BillingAccount   @relation(fields: [accountId], references: [id], onDelete: Cascade)
  plan    SubscriptionPlan @relation(fields: [planId], references: [id])

  @@index([accountId])
  @@index([planId])
  @@index([status])
  @@index([currentPeriodEnd])
   @@index([currentPeriodEnd, status]) // Find expiring active subscriptions
  @@index([status, currentPeriodEnd, cancelAtPeriodEnd]) // Renewal processing
  @@index([planId, status]) // Plan usage analytics
}

////////////////////
/// USAGE TRACKING
////////////////////

model UsageCounter {
  id        String   @id @default(cuid())
  accountId String
  
  periodStart DateTime
  periodEnd   DateTime

  storeCount      Int @default(0)
  productCount    Int @default(0)
  orderCount      Int @default(0)
  staffCount      Int @default(0)
  apiRequestCount Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  account BillingAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@unique([accountId, periodStart])
  @@index([accountId, periodStart, periodEnd])
  @@index([periodEnd])
    @@index([accountId, periodEnd]) // Find expiring periods
  @@index([periodEnd, accountId]) // Cleanup old counters
}

////////////////////
/// INVOICES
////////////////////

model Invoice {
  id        String   @id @default(cuid())
  accountId String
  
  amount   Int
  currency String @default("INR")
  
  periodStart DateTime
  periodEnd   DateTime
  
  status        PaymentStatus @default(PENDING)
  paidAt        DateTime?
  paymentId     String?
  
  createdAt DateTime @default(now())

  account BillingAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@index([accountId])
  @@index([status])
  @@index([createdAt])
   @@index([accountId, status, createdAt]) // Account invoice list
  @@index([status, createdAt]) // Process pending invoices
  @@index([accountId, periodStart, periodEnd]) // Find invoice by period
  @@index([paymentId]) // Webhook payment matching
}

////////////////////
/// STORES (TENANTS)
////////////////////

model Store {
  id                 String   @id @default(cuid())
  accountId          String
  name               String
  slug               String   @unique
  currency           String   @default("INR") // Store currency code (e.g. "USD", "INR")
  requirePhoneNumber Boolean  @default(false) // Store setting: require phone for orders
  createdAt          DateTime @default(now())
  
  account        BillingAccount   @relation(fields: [accountId], references: [id], onDelete: Cascade)
  staff          StoreStaff[]
  products       Product[]
  orders         Order[]
  payments       Payment[]
  apiKeys        ApiKey[]
  paymentConfigs PaymentConfig[]
  categories     Category[]
  discounts      Discount[]
  invitations    StoreInvitation[]
  notificationConfigs   NotificationConfig[]
  notificationLogs      NotificationLog[]
  notificationTemplates NotificationTemplate[]
  productSchemas ProductSchema[]
  variantSchemas VariantSchema[]
  carts          Cart[]
  layouts        Layout[]

  @@index([slug])
  @@index([accountId])
}

model Layout {
  id          String   @id @default(cuid())
  storeId     String
  page        String
  tree        Json
  isPublished Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  store       Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@unique([storeId, page, isPublished])
  @@index([storeId])
}

////////////////////
/// STORE STAFF (RBAC)
////////////////////

model StoreStaff {
  id        String    @id @default(cuid())
  storeId   String
  userId    String
  role      StoreRole
  createdAt DateTime  @default(now())

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([storeId, userId])
  @@index([storeId])
  @@index([userId])
}

////////////////////
/// PRODUCTS
////////////////////

model Product {
  id          String    @id @default(cuid())
  storeId     String
  categoryId  String?   // Optional category for organization
  name        String
  description String?
  customData  Json?     // Store custom attributes based on ProductSchema
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())

  store           Store            @relation(fields: [storeId], references: [id], onDelete: Cascade)
  category        Category?        @relation(fields: [categoryId], references: [id])
  productSchemaId String?
  productSchema   ProductSchema?   @relation(fields: [productSchemaId], references: [id])
  variants        ProductVariant[]
  images          Image[]

  discountProducts DiscountProduct[]

  @@index([storeId])
  @@index([storeId, isActive])
  @@index([storeId, createdAt])
  @@index([categoryId])
}

model ProductVariant {
  id         String   @id @default(cuid())
  productId  String
  sku        String   @unique
  price      Int      // Price in smallest currency unit
  stock      Int
  customData Json?    // Store custom variant attributes based on VariantSchema
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  images  Image[]

  orderLines OrderLine[]
  cartItems  CartItem[]

  @@index([productId])
  @@index([productId, isActive])
  @@index([productId, stock])
  @@index([stock, isActive]) // Find low stock items
  @@index([sku])
}

model Image {
  id        String   @id @default(cuid())
  url       String
  alt       String?
  position  Int      @default(0)
  createdAt DateTime @default(now())

  productId String?
  variantId String?

  product Product?        @relation(fields: [productId], references: [id], onDelete: Cascade)
  variant ProductVariant? @relation(fields: [variantId], references: [id], onDelete: Cascade)

  @@index([productId])
  @@index([variantId])
}

////////////////////
/// CUSTOM SCHEMAS
////////////////////

model ProductSchema {
  id        String   @id @default(cuid())
  storeId   String
  version   Int      @default(1)
  name      String   // Human-readable name like "Default Product Schema"
  fields    Json     // Schema definition with field types, validation, visibility
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)
  products Product[]

  @@unique([storeId, name, version])
  @@index([storeId, isActive])
}

model VariantSchema {
  id        String   @id @default(cuid())
  storeId   String
  version   Int      @default(1)
  name      String   // Human-readable name like "Default Variant Schema"
  fields    Json     // Schema definition extending product schema
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@unique([storeId, version])
  @@index([storeId, isActive])
}

model Category {
  id        String    @id @default(cuid())
  storeId   String
  name      String
  slug      String
  parentId  String?
  createdAt DateTime  @default(now())
  deletedAt DateTime?

  store    Store      @relation(fields: [storeId], references: [id], onDelete: Cascade)
  parent   Category?  @relation("CategoryTree", fields: [parentId], references: [id])
  children Category[] @relation("CategoryTree")

  products Product[]

  discountCategories DiscountCategory[]

  @@index([storeId, deletedAt])
  @@index([parentId])
  @@unique([storeId, slug, deletedAt])
}

////////////////////
/// DISCOUNTS & OFFERS
////////////////////

model Discount {
  id          String        @id @default(cuid())
  storeId     String
  code        String?
  name        String
  description String?
  type        DiscountType
  value       Int
  scope       DiscountScope

  startsAt DateTime
  endsAt   DateTime

  maxUsageCount   Int?
  maxUsagePerUser Int?
  minOrderValue   Int?
  isStackable     Boolean @default(false)

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  products   DiscountProduct[]
  categories DiscountCategory[]
  usages     DiscountUsage[]
  orders     OrderDiscount[]

  @@unique([storeId, code])
  @@index([storeId, isActive, startsAt, endsAt])
  @@index([storeId, code])
  @@index([startsAt, endsAt])
   @@index([storeId, code, isActive]) // Fast coupon validation
 
  @@index([storeId, scope, isActive]) // Filter by scope
  @@index([endsAt, isActive]) // Cleanup expired discounts
}

model DiscountProduct {
  discountId String
  productId  String

  discount Discount @relation(fields: [discountId], references: [id], onDelete: Cascade)
  product  Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@id([discountId, productId])
  @@index([productId])
}

model DiscountCategory {
  discountId String
  categoryId String

  discount Discount @relation(fields: [discountId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@id([discountId, categoryId])
  @@index([categoryId])
}

model DiscountUsage {
  id         String   @id @default(cuid())
  discountId String
  userId     String?
  orderId    String
  usedAt     DateTime @default(now())

  discount Discount @relation(fields: [discountId], references: [id], onDelete: Cascade)
  user     User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([discountId])
  @@index([userId])
  @@index([orderId])
  @@index([discountId, userId]) // Per-user usage count
  @@index([discountId, usedAt]) // Usage over time
  @@index([userId, usedAt]) // User discount history
}

////////////////////
/// ORDERS
////////////////////

model Order {
  id             String      @id @default(cuid())
  storeId        String
  userId         String?
  billingAddressId String?
  subtotal       Int
  discountAmount Int         @default(0)
  total          Int
  currency       String      @default("INR")
  status         OrderStatus
  completedAt    DateTime?
  createdAt      DateTime    @default(now())

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)
  user  User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  billingAddress BillingAddress? @relation(fields: [billingAddressId], references: [id], onDelete: SetNull)

  lines     OrderLine[]
  payments  Payment[]
  discounts OrderDiscount[]

  @@index([storeId, createdAt])
  @@index([userId])
  @@index([storeId, status])
  @@index([createdAt])
  @@index([billingAddressId])
    @@index([storeId, userId, createdAt]) // User's order history
  @@index([storeId, status, createdAt]) // Status filtering with time
  @@index([userId, createdAt]) // User order list across stores
  @@index([storeId, createdAt, status]) // Covering index for common queries
}

model OrderLine {
  orderId         String
  variantId       String
  quantity        Int
  price           Int
  productSnapshot Json  // Snapshot of product.customData at checkout
  variantSnapshot Json  // Snapshot of variant.customData at checkout

  order   Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  variant ProductVariant @relation(fields: [variantId], references: [id])

  @@id([orderId, variantId])
  @@index([variantId])
}

model OrderDiscount {
  orderId    String
  discountId String
  amount     Int

  order    Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  discount Discount @relation(fields: [discountId], references: [id], onDelete: Cascade)

  @@id([orderId, discountId])
  @@index([discountId])
}

////////////////////
/// PAYMENTS
////////////////////

model Payment {
  id                String          @id @default(cuid())
  orderId           String
  storeId           String
  provider          PaymentProvider
  amount            Int
  currency          String          @default("INR")
  status            PaymentStatus   @default(PENDING)
  idempotencyKey    String?         @unique
  providerPaymentId String?         @unique
  createdAt         DateTime        @default(now())

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@index([storeId])
  @@index([orderId])
  @@index([storeId, status])
  @@index([createdAt])
  @@index([idempotencyKey])
  @@index([providerPaymentId])
   @@index([storeId, createdAt]) // List payments by store with time sorting
  @@index([storeId, provider, status]) // Filter by provider and status
  @@index([providerPaymentId, storeId]) // Webhook lookups (compound for tenant isolation)
  @@index([storeId, provider, createdAt]) // Analytics queries
}

model PaymentConfig {
  id            String          @id @default(cuid())
  storeId       String
  provider      PaymentProvider
  apiKey        String
  apiSecret     String?
  webhookSecret String?
  isLive        Boolean         @default(false)
  isActive      Boolean         @default(true)
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@unique([storeId, provider])
  @@index([storeId, isActive])
}

////////////////////
/// API KEYS (EXTERNAL APPS)
////////////////////

model ApiKey {
  id         String    @id @default(cuid())
  keyId      String    @unique
  keyHash    String
  storeId    String
  name       String?
  scopes     String[]
  revokedAt  DateTime?
  lastUsedAt DateTime?
  createdAt  DateTime  @default(now())

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@index([storeId])
  @@index([keyId])
    @@index([storeId, revokedAt]) // List active keys
  @@index([storeId, lastUsedAt]) // Sort by usage
  @@index([keyId, revokedAt]) // Fast validation with revocation check
}

////////////////////
/// STORE INVITATIONS
////////////////////

model StoreInvitation {
  id        String    @id @default(cuid())
  storeId   String
  email     String
  role      StoreRole @default(MANAGER)
  token     String    @unique @default(cuid()) // For potential direct links
  expiresAt DateTime? // Optional expiration
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@unique([storeId, email])
  @@index([email])
  @@index([token])
}

model AccountInvitation {
  id        String   @id @default(cuid())
  accountId String
  email     String
  role      String   @default("MEMBER")
  token     String   @unique @default(cuid())
  expiresAt DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  account BillingAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@unique([accountId, email])
  @@index([email])
  @@index([token])
}

////////////////////
/// NOTIFICATIONS
////////////////////

model NotificationConfig {
  id        String              @id @default(cuid())
  storeId   String
  channel   NotificationChannel
  
  // Generic config store (encrypted ideally, but simple string/json for now)
  config    Json    // Credentials like { apiKey, apiSecret, fromEmail, vapidKeys, etc }
  
  isActive  Boolean @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@unique([storeId, channel])
  @@index([storeId, isActive])
}

model NotificationLog {
  id        String              @id @default(cuid())
  storeId   String
  channel   NotificationChannel
  
  recipient String  // Phone, Email, Validation Token
  content   String  @db.Text
  
  status    NotificationStatus @default(QUEUED)
  error     String?            @db.Text
  
  providerMessageId String? // External ID from provider
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@index([storeId, channel, createdAt])
  @@index([status])
}

model NotificationTemplate {
  id        String              @id @default(cuid())
  storeId   String
  name      String
  channel   NotificationChannel
  subject   String?             // For Email/Push title
  content   String              @db.Text
  
  // Variables used in this template for validation/preview
  variables String[] // e.g. ["customerName", "orderId", "total"]
  
  isActive  Boolean @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@unique([storeId, name])
  @@index([storeId, channel])
}

////////////////////
/// CART SYSTEM
////////////////////

model Cart {
  id        String   @id @default(cuid())
  storeId   String
  userId    String?  // Optional: associated user if logged in
  sessionId String?  // Optional: for guest carts
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)
  user  User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  items CartItem[]
  events CartEvent[]

  @@index([storeId])
  @@index([userId])
  @@index([sessionId])
  @@unique([storeId, userId]) // One active cart per user per store (optional logic, but good for enforcement)
  @@unique([storeId, sessionId])  // One active cart per session per store
}

model CartItem {
  id        String   @id @default(cuid())
  cartId    String
  variantId String
  quantity  Int      @default(1)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  cart    Cart           @relation(fields: [cartId], references: [id], onDelete: Cascade)
  variant ProductVariant @relation(fields: [variantId], references: [id], onDelete: Cascade)

  @@unique([cartId, variantId])
  @@index([cartId])
  @@index([variantId])
}

enum CartEventType {
  CREATED
  ITEM_ADDED
  ITEM_UPDATED
  ITEM_REMOVED
  ABANDONED  // Can be marked by a job
  CONVERTED  // Marked when order is placed
  MERGED     // When guest cart merges with user cart
}

model CartEvent {
  id        String        @id @default(cuid())
  cartId    String
  type      CartEventType
  metadata  Json?         // Store details like { variantId, quantity, oldQuantity }
  
  createdAt DateTime @default(now())

  cart Cart @relation(fields: [cartId], references: [id], onDelete: Cascade)

  @@index([cartId])
  @@index([type])
  @@index([createdAt])
}
