BACKEND CODE EXPORT
Generated: Saturday 10 January 2026 08:06:27 PM IST
================================================================================
FILE: prisma/schema.prisma
================================================================================

generator client {
  provider = "prisma-client-js"
  output   = "../app/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

////////////////////
/// ENUMS
////////////////////

enum StoreRole {
  OWNER
  MANAGER
  SUPPORT
}

enum OrderStatus {
  PENDING
  PAID
  CANCELLED
  REFUNDED
}

enum PaymentProvider {
  STRIPE
  RAZORPAY
  MANUAL
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum DiscountType {
  PERCENTAGE
  FIXED_AMOUNT
}

enum DiscountScope {
  STORE_WIDE
  CATEGORY
  PRODUCT
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  TRIALING
}

enum PlanType {
  FREE
  BASIC
  PRO
  ENTERPRISE
}

////////////////////
/// USERS (Auth.js)
////////////////////

model User {
  id               String           @id @default(cuid())
  email            String           @unique
  name             String?
  image            String?
  createdAt        DateTime         @default(now())
  billingAddresses BillingAddress[]
  accounts         Account[]
  sessions         Session[]
  stores           StoreStaff[]
  discountUsages   DiscountUsage[]
  ownedAccounts    AccountUser[]
}

model BillingAddress {
  id         String   @id @default(cuid())
  userId     String
  address1   String
  address2   String?
  city       String
  state      String
  postalCode String
  country    String
  createdAt  DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Account {
  id                String @id @default(cuid())
  userId            String
  provider          String
  providerAccountId String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  expiresAt DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

////////////////////
/// ACCOUNTS (ORGANIZATIONS)
////////////////////

model BillingAccount {
  id        String   @id @default(cuid())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users        AccountUser[]
  stores       Store[]
  subscription AccountSubscription?
  usage        UsageCounter[]
  invoices     Invoice[]

  @@index([createdAt])
}

model AccountUser {
  id        String   @id @default(cuid())
  accountId String
  userId    String
  role      String   @default("MEMBER")
  createdAt DateTime @default(now())

  account BillingAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  user    User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([accountId, userId])
  @@index([accountId])
  @@index([userId])
}

////////////////////
/// SUBSCRIPTION PLANS
////////////////////

model SubscriptionPlan {
  id          String   @id @default(cuid())
  type        PlanType @unique
  name        String
  description String?
  price       Int

  maxStores              Int?
  maxProducts            Int?
  maxOrdersPerMonth      Int?
  maxStaffMembers        Int?
  maxAPIRequestsPerMonth Int?

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  subscriptions AccountSubscription[]

  @@index([type])
  @@index([isActive])
  
}

////////////////////
/// ACCOUNT SUBSCRIPTIONS
////////////////////

model AccountSubscription {
  id        String             @id @default(cuid())
  accountId String             @unique
  planId    String
  status    SubscriptionStatus @default(ACTIVE)

  currentPeriodStart DateTime
  currentPeriodEnd   DateTime

  cancelAtPeriodEnd Boolean @default(false)
  canceledAt        DateTime?

  trialEndsAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  account BillingAccount   @relation(fields: [accountId], references: [id], onDelete: Cascade)
  plan    SubscriptionPlan @relation(fields: [planId], references: [id])

  @@index([accountId])
  @@index([planId])
  @@index([status])
  @@index([currentPeriodEnd])
   @@index([currentPeriodEnd, status]) // Find expiring active subscriptions
  @@index([status, currentPeriodEnd, cancelAtPeriodEnd]) // Renewal processing
  @@index([planId, status]) // Plan usage analytics
}

////////////////////
/// USAGE TRACKING
////////////////////

model UsageCounter {
  id        String   @id @default(cuid())
  accountId String
  
  periodStart DateTime
  periodEnd   DateTime

  storeCount      Int @default(0)
  productCount    Int @default(0)
  orderCount      Int @default(0)
  staffCount      Int @default(0)
  apiRequestCount Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  account BillingAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@unique([accountId, periodStart])
  @@index([accountId, periodStart, periodEnd])
  @@index([periodEnd])
    @@index([accountId, periodEnd]) // Find expiring periods
  @@index([periodEnd, accountId]) // Cleanup old counters
}

////////////////////
/// INVOICES
////////////////////

model Invoice {
  id        String   @id @default(cuid())
  accountId String
  
  amount   Int
  currency String @default("INR")
  
  periodStart DateTime
  periodEnd   DateTime
  
  status        PaymentStatus @default(PENDING)
  paidAt        DateTime?
  paymentId     String?
  
  createdAt DateTime @default(now())

  account BillingAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@index([accountId])
  @@index([status])
  @@index([createdAt])
   @@index([accountId, status, createdAt]) // Account invoice list
  @@index([status, createdAt]) // Process pending invoices
  @@index([accountId, periodStart, periodEnd]) // Find invoice by period
  @@index([paymentId]) // Webhook payment matching
}

////////////////////
/// STORES (TENANTS)
////////////////////

model Store {
  id        String   @id @default(cuid())
  accountId String
  name      String
  slug      String   @unique
  createdAt DateTime @default(now())
  
  account        BillingAccount   @relation(fields: [accountId], references: [id], onDelete: Cascade)
  staff          StoreStaff[]
  products       Product[]
  orders         Order[]
  payments       Payment[]
  apiKeys        ApiKey[]
  paymentConfigs PaymentConfig[]
  categories     Category[]
  facets         Facet[]
  discounts      Discount[]

  @@index([slug])
  @@index([accountId])
}

////////////////////
/// STORE STAFF (RBAC)
////////////////////

model StoreStaff {
  id        String    @id @default(cuid())
  storeId   String
  userId    String
  role      StoreRole
  createdAt DateTime  @default(now())

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([storeId, userId])
  @@index([storeId])
  @@index([userId])
}

////////////////////
/// PRODUCTS
////////////////////

model Product {
  id          String    @id @default(cuid())
  storeId     String
  categoryId  String?
  name        String
  description String?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  deletedAt   DateTime?

  store    Store               @relation(fields: [storeId], references: [id], onDelete: Cascade)
  category Category?           @relation(fields: [categoryId], references: [id])
  variants ProductVariant[]
  images   Image[]
  facets   ProductFacetValue[]

  discountProducts DiscountProduct[]

  @@index([storeId, deletedAt])
  @@index([categoryId])
  @@index([storeId, isActive, deletedAt])
  
}

model ProductVariant {
  id        String    @id @default(cuid())
  productId String
  sku       String
  price     Int
  stock     Int
  isActive  Boolean   @default(true)
  createdAt DateTime  @default(now())
  deletedAt DateTime?

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  images  Image[]
  facets  VariantFacetValue[]

  orderLines OrderLine[]

  @@index([productId, deletedAt])
  @@index([sku, deletedAt])
  @@index([productId, isActive, deletedAt])
  @@index([stock])
  @@unique([sku, deletedAt])
   @@index([productId, isActive, stock, deletedAt]) // Filter available variants
  @@index([stock, isActive, deletedAt]) // Find low stock items
  @@index([sku, isActive, deletedAt]) // SKU lookups for active items
}

model Image {
  id        String   @id @default(cuid())
  url       String
  alt       String?
  position  Int      @default(0)
  createdAt DateTime @default(now())

  productId String?
  variantId String?

  product Product?        @relation(fields: [productId], references: [id], onDelete: Cascade)
  variant ProductVariant? @relation(fields: [variantId], references: [id], onDelete: Cascade)

  @@index([productId])
  @@index([variantId])
}

model Facet {
  id        String   @id @default(cuid())
  storeId   String
  name      String
  code      String
  createdAt DateTime @default(now())

  store  Store        @relation(fields: [storeId], references: [id], onDelete: Cascade)
  values FacetValue[]

  @@unique([storeId, code])
  @@index([storeId])
}

model FacetValue {
  id      String @id @default(cuid())
  facetId String
  value   String

  facet Facet @relation(fields: [facetId], references: [id], onDelete: Cascade)

  productLinks ProductFacetValue[]
  variantLinks VariantFacetValue[]

  @@index([facetId])
}

model ProductFacetValue {
  productId    String
  facetValueId String

  product    Product    @relation(fields: [productId], references: [id], onDelete: Cascade)
  facetValue FacetValue @relation(fields: [facetValueId], references: [id], onDelete: Cascade)

  @@id([productId, facetValueId])
}

model VariantFacetValue {
  variantId    String
  facetValueId String

  variant    ProductVariant @relation(fields: [variantId], references: [id], onDelete: Cascade)
  facetValue FacetValue     @relation(fields: [facetValueId], references: [id], onDelete: Cascade)

  @@id([variantId, facetValueId])
}

model Category {
  id        String    @id @default(cuid())
  storeId   String
  name      String
  slug      String
  parentId  String?
  createdAt DateTime  @default(now())
  deletedAt DateTime?

  store    Store      @relation(fields: [storeId], references: [id], onDelete: Cascade)
  parent   Category?  @relation("CategoryTree", fields: [parentId], references: [id])
  children Category[] @relation("CategoryTree")

  products Product[]

  discountCategories DiscountCategory[]

  @@index([storeId, deletedAt])
  @@index([parentId])
  @@unique([storeId, slug, deletedAt])
}

////////////////////
/// DISCOUNTS & OFFERS
////////////////////

model Discount {
  id          String        @id @default(cuid())
  storeId     String
  code        String?
  name        String
  description String?
  type        DiscountType
  value       Int
  scope       DiscountScope

  startsAt DateTime
  endsAt   DateTime

  maxUsageCount   Int?
  maxUsagePerUser Int?
  minOrderValue   Int?
  isStackable     Boolean @default(false)

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  products   DiscountProduct[]
  categories DiscountCategory[]
  usages     DiscountUsage[]
  orders     OrderDiscount[]

  @@unique([storeId, code])
  @@index([storeId, isActive, startsAt, endsAt])
  @@index([storeId, code])
  @@index([startsAt, endsAt])
   @@index([storeId, code, isActive]) // Fast coupon validation
 
  @@index([storeId, scope, isActive]) // Filter by scope
  @@index([endsAt, isActive]) // Cleanup expired discounts
}

model DiscountProduct {
  discountId String
  productId  String

  discount Discount @relation(fields: [discountId], references: [id], onDelete: Cascade)
  product  Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@id([discountId, productId])
  @@index([productId])
}

model DiscountCategory {
  discountId String
  categoryId String

  discount Discount @relation(fields: [discountId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@id([discountId, categoryId])
  @@index([categoryId])
}

model DiscountUsage {
  id         String   @id @default(cuid())
  discountId String
  userId     String?
  orderId    String
  usedAt     DateTime @default(now())

  discount Discount @relation(fields: [discountId], references: [id], onDelete: Cascade)
  user     User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([discountId])
  @@index([userId])
  @@index([orderId])
  @@index([discountId, userId]) // Per-user usage count
  @@index([discountId, usedAt]) // Usage over time
  @@index([userId, usedAt]) // User discount history
}

////////////////////
/// ORDERS
////////////////////

model Order {
  id             String      @id @default(cuid())
  storeId        String
  userId         String?
  subtotal       Int
  discountAmount Int         @default(0)
  total          Int
  currency       String      @default("INR")
  status         OrderStatus
  createdAt      DateTime    @default(now())

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  lines     OrderLine[]
  payments  Payment[]
  discounts OrderDiscount[]

  @@index([storeId, createdAt])
  @@index([userId])
  @@index([storeId, status])
  @@index([createdAt])
    @@index([storeId, userId, createdAt]) // User's order history
  @@index([storeId, status, createdAt]) // Status filtering with time
  @@index([userId, createdAt]) // User order list across stores
  @@index([storeId, createdAt, status]) // Covering index for common queries
}

model OrderLine {
  orderId   String
  variantId String
  quantity  Int
  price     Int

  order   Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  variant ProductVariant @relation(fields: [variantId], references: [id])

  @@id([orderId, variantId])
  @@index([variantId])
  
}

model OrderDiscount {
  orderId    String
  discountId String
  amount     Int

  order    Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  discount Discount @relation(fields: [discountId], references: [id], onDelete: Cascade)

  @@id([orderId, discountId])
  @@index([discountId])
}

////////////////////
/// PAYMENTS
////////////////////

model Payment {
  id                String          @id @default(cuid())
  orderId           String
  storeId           String
  provider          PaymentProvider
  amount            Int
  currency          String          @default("INR")
  status            PaymentStatus   @default(PENDING)
  idempotencyKey    String?         @unique
  providerPaymentId String?         @unique
  createdAt         DateTime        @default(now())

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@index([storeId])
  @@index([orderId])
  @@index([storeId, status])
  @@index([createdAt])
  @@index([idempotencyKey])
  @@index([providerPaymentId])
   @@index([storeId, createdAt]) // List payments by store with time sorting
  @@index([storeId, provider, status]) // Filter by provider and status
  @@index([providerPaymentId, storeId]) // Webhook lookups (compound for tenant isolation)
  @@index([storeId, provider, createdAt]) // Analytics queries
}

model PaymentConfig {
  id            String          @id @default(cuid())
  storeId       String
  provider      PaymentProvider
  apiKey        String
  apiSecret     String?
  webhookSecret String?
  isLive        Boolean         @default(false)
  isActive      Boolean         @default(true)
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@unique([storeId, provider])
  @@index([storeId, isActive])
}

////////////////////
/// API KEYS (EXTERNAL APPS)
////////////////////

model ApiKey {
  id         String    @id @default(cuid())
  keyId      String    @unique
  keyHash    String
  storeId    String
  name       String?
  scopes     String[]
  revokedAt  DateTime?
  lastUsedAt DateTime?
  createdAt  DateTime  @default(now())

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@index([storeId])
  @@index([keyId])
    @@index([storeId, revokedAt]) // List active keys
  @@index([storeId, lastUsedAt]) // Sort by usage
  @@index([keyId, revokedAt]) // Fast validation with revocation check
}


================================================================================
FILE: lib/auth.ts
================================================================================

import NextAuth from "next-auth";
import Google from "next-auth/providers/google";
import Instagram from "next-auth/providers/instagram";
import { PrismaAdapter } from "@auth/prisma-adapter";
import { prisma } from "@/lib/prisma";

export const { handlers, signIn, signOut, auth } = NextAuth({
  adapter: PrismaAdapter(prisma),
  
  providers: [
    Google({
      clientId: process.env.AUTH_GOOGLE_ID!,
      clientSecret: process.env.AUTH_GOOGLE_SECRET!,
      authorization: {
        params: {
          prompt: "consent",
          access_type: "offline",
          response_type: "code",
        },
      },
    }),
    
    Instagram({
      clientId: process.env.AUTH_INSTAGRAM_ID!,
      clientSecret: process.env.AUTH_INSTAGRAM_SECRET!,
    }),
  ],

  session: {
    strategy: "database",
    maxAge: 30 * 24 * 60 * 60, // 30 days
    updateAge: 24 * 60 * 60, // 24 hours
  },

  pages: {
    signIn: "/auth/signin",
    signOut: "/auth/signout",
    error: "/auth/error",
  },

  callbacks: {
    async session({ session, user }) {
      if (session.user) {
        session.user.id = user.id;
      }
      return session;
    },

    async signIn({ user, account, profile }) {
      // Allow sign in
      return true;
    },

    async redirect({ url, baseUrl }) {
      // Redirect to dashboard after sign in
      if (url.startsWith("/")) return `${baseUrl}${url}`;
      if (new URL(url).origin === baseUrl) return url;
      return baseUrl;
    },
  },

  events: {
    async createUser({ user }) {
      console.log("New user created:", user.id);
      // You can add custom logic here, e.g., send welcome email
    },

    async signIn({ user, account, profile, isNewUser }) {
      console.log("User signed in:", user.id);
    },

    async signOut({ token, session }) {
      console.log("User signed out");
    },
  },

  debug: process.env.NODE_ENV === "development",
});


================================================================================
FILE: lib/errors.ts
================================================================================

/**
 * Base application error class
 */
export class AppError extends Error {
  public readonly statusCode: number;
  public readonly isOperational: boolean;

  constructor(message: string, statusCode: number = 500, isOperational: boolean = true) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.name = this.constructor.name;

    Error.captureStackTrace(this, this.constructor);
  }
}

/**
 * Permission/Authorization errors (403)
 */
export class PermissionError extends AppError {
  constructor(message: string = 'Permission denied') {
    super(message, 403);
  }
}

/**
 * Resource not found errors (404)
 */
export class NotFoundError extends AppError {
  constructor(resource: string = 'Resource') {
    super(`${resource} not found`, 404);
  }
}

/**
 * Validation errors (400)
 */
export class ValidationError extends AppError {
  public readonly field?: string;

  constructor(message: string, field?: string) {
    super(message, 400);
    this.field = field;
  }
}

/**
 * Usage/Quota limit errors (429)
 */
export class UsageLimitError extends AppError {
  public readonly limit: number;
  public readonly current: number;
  public readonly resource: string;

  constructor(message: string, limit: number, current: number, resource: string = 'resource') {
    super(message, 429);
    this.limit = limit;
    this.current = current;
    this.resource = resource;
  }
}

/**
 * Authentication errors (401)
 */
export class AuthenticationError extends AppError {
  constructor(message: string = 'Authentication required') {
    super(message, 401);
  }
}

/**
 * Conflict errors (409) - e.g., duplicate resources
 */
export class ConflictError extends AppError {
  constructor(message: string) {
    super(message, 409);
  }
}

/**
 * Rate limiting errors (429)
 */
export class RateLimitError extends AppError {
  constructor(message: string = 'Too many requests') {
    super(message, 429);
  }
}

/**
 * External service errors (502)
 */
export class ExternalServiceError extends AppError {
  public readonly service: string;

  constructor(service: string, message: string) {
    super(`External service error: ${message}`, 502);
    this.service = service;
  }
}

/**
 * Maps error to HTTP response object
 */
export interface ErrorResponse {
  error: string;
  statusCode: number;
  details?: any;
}

/**
 * Convert error to API response format
 */
export function toErrorResponse(error: unknown): ErrorResponse {
  // Handle known AppError instances
  if (error instanceof AppError) {
    const response: ErrorResponse = {
      error: error.message,
      statusCode: error.statusCode,
    };

    // Add additional details for specific error types
    if (error instanceof ValidationError && error.field) {
      response.details = { field: error.field };
    }

    if (error instanceof UsageLimitError) {
      response.details = {
        limit: error.limit,
        current: error.current,
        resource: error.resource,
      };
    }

    return response;
  }

  // Handle Prisma errors
  if (error && typeof error === 'object' && 'code' in error) {
    return handlePrismaError(error as any);
  }

  // Handle unknown errors
  if (error instanceof Error) {
    console.error('Unhandled error:', error);
    return {
      error: process.env.NODE_ENV === 'production' 
        ? 'Internal server error' 
        : error.message,
      statusCode: 500,
    };
  }

  // Fallback for non-Error objects
  return {
    error: 'Internal server error',
    statusCode: 500,
  };
}

/**
 * Handle Prisma-specific errors
 */
function handlePrismaError(error: any): ErrorResponse {
  // Unique constraint violation
  if (error.code === 'P2002') {
    const fields = error.meta?.target || [];
    return {
      error: `A record with this ${fields.join(', ')} already exists`,
      statusCode: 409,
      details: { fields },
    };
  }

  // Foreign key constraint violation
  if (error.code === 'P2003') {
    return {
      error: 'Related record not found',
      statusCode: 400,
    };
  }

  // Record not found
  if (error.code === 'P2025') {
    return {
      error: 'Record not found',
      statusCode: 404,
    };
  }

  // Record not found for where condition
  if (error.code === 'P2001') {
    return {
      error: 'Record not found',
      statusCode: 404,
    };
  }

  // Default Prisma error
  return {
    error: 'Database operation failed',
    statusCode: 500,
  };
}

/**
 * Helper to validate required fields
 */
export function validateRequired(data: Record<string, any>, fields: string[]): void {
  for (const field of fields) {
    if (data[field] === undefined || data[field] === null || data[field] === '') {
      throw new ValidationError(`${field} is required`, field);
    }
  }
}

/**
 * Helper to validate string length
 */
export function validateLength(
  value: string, 
  field: string, 
  min?: number, 
  max?: number
): void {
  if (min !== undefined && value.length < min) {
    throw new ValidationError(`${field} must be at least ${min} characters`, field);
  }
  if (max !== undefined && value.length > max) {
    throw new ValidationError(`${field} must be at most ${max} characters`, field);
  }
}

/**
 * Helper to validate number range
 */
export function validateRange(
  value: number,
  field: string,
  min?: number,
  max?: number
): void {
  if (min !== undefined && value < min) {
    throw new ValidationError(`${field} must be at least ${min}`, field);
  }
  if (max !== undefined && value > max) {
    throw new ValidationError(`${field} must be at most ${max}`, field);
  }
}

/**
 * Helper to validate enum values
 */
export function validateEnum<T extends string>(
  value: string,
  field: string,
  enumValues: readonly T[]
): T {
  if (!enumValues.includes(value as T)) {
    throw new ValidationError(
      `${field} must be one of: ${enumValues.join(', ')}`,
      field
    );
  }
  return value as T;
}


================================================================================
FILE: lib/prisma.ts
================================================================================

import { PrismaClient } from '../app/generated/prisma/client'
import { PrismaPg } from '@prisma/adapter-pg'

const globalForPrisma = global as unknown as {
    prisma: PrismaClient
}

const adapter = new PrismaPg({
  connectionString: process.env.DATABASE_URL,
})

const prisma = globalForPrisma.prisma || new PrismaClient({
  adapter,
})

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

export default prisma


================================================================================
FILE: lib/storerole.ts
================================================================================

import { StoreRole } from '@/app/generated/prisma';

/**
 * Role hierarchy for permission checks
 */
export const ROLE_HIERARCHY: Record<StoreRole, number> = {
  OWNER: 3,
  MANAGER: 2,
  SUPPORT: 1,
};

/**
 * Check if user role meets minimum required role
 */
export function hasMinimumRole(
  userRole: StoreRole,
  minimumRole: StoreRole
): boolean {
  return ROLE_HIERARCHY[userRole] >= ROLE_HIERARCHY[minimumRole];
}

/**
 * Check if role can manage API keys and payment configs
 */
export function canManageApiKeys(role: StoreRole): boolean {
  return role === 'OWNER';
}

/**
 * Check if role can write (create/update/delete)
 */
export function canWrite(role: StoreRole): boolean {
  return role === 'OWNER' || role === 'MANAGER';
}

/**
 * Check if role can read
 */
export function canRead(role: StoreRole): boolean {
  return true; // All roles can read
}

/**
 * Get role display name
 */
export function getRoleDisplayName(role: StoreRole): string {
  const names: Record<StoreRole, string> = {
    OWNER: 'Owner',
    MANAGER: 'Manager',
    SUPPORT: 'Support',
  };
  return names[role];
}

/**
 * Get role permissions description
 */
export function getRolePermissions(role: StoreRole): string[] {
  const permissions: Record<StoreRole, string[]> = {
    OWNER: [
      'Full access to all features',
      'Manage API keys and payment configurations',
      'Manage store staff and roles',
      'View billing and subscription details',
      'Create, edit, and delete all resources',
    ],
    MANAGER: [
      'Create, edit, and delete products and orders',
      'Manage discounts and promotions',
      'View and update order status',
      'Access all reports and analytics',
      'Cannot manage API keys or payment settings',
    ],
    SUPPORT: [
      'Read-only access to all resources',
      'View products, orders, and customers',
      'View reports and analytics',
      'Cannot create, edit, or delete anything',
    ],
  };
  return permissions[role];
}

/**
 * Validate if a role transition is allowed
 */
export function canChangeRole(
  currentUserRole: StoreRole,
  targetUserCurrentRole: StoreRole,
  targetUserNewRole: StoreRole
): boolean {
  // Only OWNER can change roles
  if (currentUserRole !== 'OWNER') {
    return false;
  }

  // Cannot demote the last owner
  // (This check should be done in the service layer with actual count)
  
  return true;
}


================================================================================
FILE: dal/apiKey.dal.ts
================================================================================

import prisma from '@/lib/prisma';
import crypto from 'crypto';
import { hashApiKey } from '@/lib/utils/encryption';

/**
 * Generate and create API key
 */
export async function createApiKey(
  storeId: string,
  data: {
    name?: string;
    scopes: string[];
  }
) {
  // Generate unique key ID and secret
  const keyId = crypto.randomBytes(16).toString('hex');
  const secret = crypto.randomBytes(32).toString('hex');
  
  // Construct full key
  const fullKey = `sk_live_${keyId}_${secret}`;
  
  // Hash for storage
  const keyHash = hashApiKey(fullKey);

  const apiKey = await prisma.apiKey.create({
    data: {
      storeId,
      keyId,
      keyHash,
      name: data.name,
      scopes: data.scopes,
    },
  });

  // Return full key ONLY on creation (never again)
  return {
    ...apiKey,
    fullKey,
  };
}

/**
 * Revoke API key
 */
export async function revokeApiKey(storeId: string, keyId: string) {
  const apiKey = await prisma.apiKey.findFirst({
    where: { keyId, storeId },
  });

  if (!apiKey) {
    throw new Error('API key not found');
  }

  if (apiKey.revokedAt) {
    throw new Error('API key is already revoked');
  }

  return prisma.apiKey.update({
    where: { id: apiKey.id },
    data: {
      revokedAt: new Date(),
    },
  });
}

/**
 * Get API key by keyId (for validation)
 */
export async function getApiKeyByKeyId(keyId: string) {
  return prisma.apiKey.findUnique({
    where: { keyId },
    select: {
      id: true,
      keyId: true,
      keyHash: true,
      storeId: true,
      scopes: true,
      revokedAt: true,
      lastUsedAt: true,
      createdAt: true,
    },
  });
}

/**
 * List API keys for a store (excludes hashes)
 */
export async function listApiKeys(storeId: string) {
  return prisma.apiKey.findMany({
    where: { storeId },
    select: {
      id: true,
      keyId: true,
      name: true,
      scopes: true,
      revokedAt: true,
      lastUsedAt: true,
      createdAt: true,
    },
    orderBy: { createdAt: 'desc' },
  });
}

/**
 * Update last used timestamp
 */
export async function incrementUsage(keyId: string) {
  return prisma.apiKey.update({
    where: { keyId },
    data: {
      lastUsedAt: new Date(),
    },
  });
}

/**
 * Get API key by ID (for management)
 */
export async function getApiKeyById(storeId: string, apiKeyId: string) {
  return prisma.apiKey.findFirst({
    where: {
      id: apiKeyId,
      storeId,
    },
    select: {
      id: true,
      keyId: true,
      name: true,
      scopes: true,
      revokedAt: true,
      lastUsedAt: true,
      createdAt: true,
    },
  });
}


================================================================================
FILE: dal/category.dal.ts
================================================================================

import prisma from '@/lib/prisma';

/**
 * Create category
 */
export async function createCategory(
  storeId: string,
  data: {
    name: string;
    slug: string;
    parentId?: string;
  }
) {
  if (data.parentId) {
    const parent = await prisma.category.findFirst({
      where: { id: data.parentId, storeId, deletedAt: null },
    });
    if (!parent) {
      throw new Error('Parent category not found in this store');
    }
  }

  return prisma.category.create({
    data: {
      storeId,
      name: data.name,
      slug: data.slug,
      parentId: data.parentId,
    },
    include: {
      parent: true,
      children: {
        where: { deletedAt: null },
      },
    },
  });
}

/**
 * Update category
 */
export async function updateCategory(
  storeId: string,
  categoryId: string,
  data: {
    name?: string;
    slug?: string;
    parentId?: string;
  }
) {
  const category = await prisma.category.findFirst({
    where: { id: categoryId, storeId, deletedAt: null },
  });

  if (!category) {
    throw new Error('Category not found');
  }

  if (data.parentId) {
    const parent = await prisma.category.findFirst({
      where: { id: data.parentId, storeId, deletedAt: null },
    });
    if (!parent) {
      throw new Error('Parent category not found in this store');
    }

    if (data.parentId === categoryId) {
      throw new Error('Category cannot be its own parent');
    }
  }

  return prisma.category.update({
    where: { id: categoryId },
    data,
    include: {
      parent: true,
      children: {
        where: { deletedAt: null },
      },
    },
  });
}

/**
 * Soft delete category
 */
export async function deleteCategory(storeId: string, categoryId: string) {
  const category = await prisma.category.findFirst({
    where: { id: categoryId, storeId, deletedAt: null },
  });

  if (!category) {
    throw new Error('Category not found');
  }

  return prisma.category.update({
    where: { id: categoryId },
    data: {
      deletedAt: new Date(),
    },
  });
}

/**
 * List categories (excludes soft-deleted)
 */
export async function listCategories(storeId: string) {
  return prisma.category.findMany({
    where: { storeId, deletedAt: null },
    include: {
      parent: {
        where: { deletedAt: null },
      },
      children: {
        where: { deletedAt: null },
      },
      _count: {
        select: {
          products: {
            where: { deletedAt: null },
          },
        },
      },
    },
    orderBy: { name: 'asc' },
  });
}

/**
 * Get category tree (excludes soft-deleted)
 */
export async function getCategoryTree(storeId: string) {
  const allCategories = await prisma.category.findMany({
    where: { storeId, deletedAt: null },
    include: {
      children: {
        where: { deletedAt: null },
        include: {
          children: {
            where: { deletedAt: null },
          },
        },
      },
      _count: {
        select: {
          products: {
            where: { deletedAt: null },
          },
        },
      },
    },
    orderBy: { name: 'asc' },
  });

  return allCategories.filter(cat => cat.parentId === null);
}

/**
 * Get category by ID (excludes soft-deleted)
 */
export async function getCategoryById(storeId: string, categoryId: string) {
  return prisma.category.findFirst({
    where: {
      id: categoryId,
      storeId,
      deletedAt: null,
    },
    include: {
      parent: {
        where: { deletedAt: null },
      },
      children: {
        where: { deletedAt: null },
      },
      _count: {
        select: {
          products: {
            where: { deletedAt: null },
          },
        },
      },
    },
  });
}


================================================================================
FILE: dal/discount.dal.ts
================================================================================

import   prisma   from '@/lib/prisma';
import { DiscountType, DiscountScope, Prisma } from '@/app/generated/prisma';

export async function createDiscount(
  storeId: string,
  data: {
    code?: string;
    name: string;
    description?: string;
    type: DiscountType;
    value: number;
    scope: DiscountScope;
    startsAt: Date;
    endsAt: Date;
    maxUsageCount?: number;
    maxUsagePerUser?: number;
    minOrderValue?: number;
    isStackable: boolean;
    productIds?: string[];
    categoryIds?: string[];
  }
) {
  return prisma.discount.create({
    data: {
      storeId,
      code: data.code?.toUpperCase() || null,
      name: data.name,
      description: data.description,
      type: data.type,
      value: data.value,
      scope: data.scope,
      startsAt: data.startsAt,
      endsAt: data.endsAt,
      maxUsageCount: data.maxUsageCount,
      maxUsagePerUser: data.maxUsagePerUser,
      minOrderValue: data.minOrderValue,
      isStackable: data.isStackable,
      products: data.productIds?.length
        ? {
            create: data.productIds.map(productId => ({ productId })),
          }
        : undefined,
      categories: data.categoryIds?.length
        ? {
            create: data.categoryIds.map(categoryId => ({ categoryId })),
          }
        : undefined,
    },
    include: {
      products: {
        include: {
          product: true,
        },
      },
      categories: {
        include: {
          category: true,
        },
      },
    },
  });
}

export async function updateDiscount(
  storeId: string,
  discountId: string,
  data: {
    code?: string;
    name?: string;
    description?: string;
    value?: number;
    startsAt?: Date;
    endsAt?: Date;
    maxUsageCount?: number;
    maxUsagePerUser?: number;
    minOrderValue?: number;
    isStackable?: boolean;
    isActive?: boolean;
    productIds?: string[];
    categoryIds?: string[];
  }
) {
  // Verify discount belongs to store
  const discount = await prisma.discount.findFirst({
    where: { id: discountId, storeId },
  });

  if (!discount) {
    throw new Error('Discount not found');
  }

  // Handle product/category updates
  const updateData: any = {
    ...(data.code !== undefined && { code: data.code?.toUpperCase() || null }),
    ...(data.name !== undefined && { name: data.name }),
    ...(data.description !== undefined && { description: data.description }),
    ...(data.value !== undefined && { value: data.value }),
    ...(data.startsAt !== undefined && { startsAt: data.startsAt }),
    ...(data.endsAt !== undefined && { endsAt: data.endsAt }),
    ...(data.maxUsageCount !== undefined && { maxUsageCount: data.maxUsageCount }),
    ...(data.maxUsagePerUser !== undefined && { maxUsagePerUser: data.maxUsagePerUser }),
    ...(data.minOrderValue !== undefined && { minOrderValue: data.minOrderValue }),
    ...(data.isStackable !== undefined && { isStackable: data.isStackable }),
    ...(data.isActive !== undefined && { isActive: data.isActive }),
  };

  // Update products if provided
  if (data.productIds !== undefined) {
    await prisma.discountProduct.deleteMany({
      where: { discountId },
    });
    if (data.productIds.length > 0) {
      updateData.products = {
        create: data.productIds.map(productId => ({ productId })),
      };
    }
  }

  // Update categories if provided
  if (data.categoryIds !== undefined) {
    await prisma.discountCategory.deleteMany({
      where: { discountId },
    });
    if (data.categoryIds.length > 0) {
      updateData.categories = {
        create: data.categoryIds.map(categoryId => ({ categoryId })),
      };
    }
  }

  return prisma.discount.update({
    where: { id: discountId },
    data: updateData,
    include: {
      products: {
        include: {
          product: true,
        },
      },
      categories: {
        include: {
          category: true,
        },
      },
    },
  });
}

export async function deleteDiscount(storeId: string, discountId: string) {
  const discount = await prisma.discount.findFirst({
    where: { id: discountId, storeId },
  });

  if (!discount) {
    throw new Error('Discount not found');
  }

  return prisma.discount.delete({
    where: { id: discountId },
  });
}

export async function getDiscountById(storeId: string, discountId: string) {
  return prisma.discount.findFirst({
    where: {
      id: discountId,
      storeId,
    },
    include: {
      products: {
        include: {
          product: true,
        },
      },
      categories: {
        include: {
          category: true,
        },
      },
      _count: {
        select: {
          usages: true,
        },
      },
    },
  });
}

export async function getDiscountByCode(storeId: string, code: string) {
  return prisma.discount.findFirst({
    where: {
      storeId,
      code: code.toUpperCase(),
      isActive: true,
    },
    include: {
      products: {
        include: {
          product: true,
        },
      },
      categories: {
        include: {
          category: true,
        },
      },
    },
  });
}

export async function listDiscounts(
  storeId: string,
  filters?: {
    isActive?: boolean;
    scope?: DiscountScope;
    skip?: number;
    take?: number;
  }
) {
  const where: Prisma.DiscountWhereInput = {
    storeId,
    ...(filters?.isActive !== undefined && { isActive: filters.isActive }),
    ...(filters?.scope && { scope: filters.scope }),
  };

  const [discounts, total] = await Promise.all([
    prisma.discount.findMany({
      where,
      skip: filters?.skip ?? 0,
      take: filters?.take ?? 50,
      include: {
        products: {
          include: {
            product: true,
          },
        },
        categories: {
          include: {
            category: true,
          },
        },
        _count: {
          select: {
            usages: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    }),
    prisma.discount.count({ where }),
  ]);

  return { discounts, total };
}

/**
 * Get applicable discounts for order (time-constrained, active)
 */
export async function getApplicableDiscounts(
  storeId: string,
  now: Date = new Date()
) {
  return prisma.discount.findMany({
    where: {
      storeId,
      isActive: true,
      startsAt: { lte: now },
      endsAt: { gte: now },
    },
    include: {
      products: {
        include: {
          product: true,
        },
      },
      categories: {
        include: {
          category: true,
        },
      },
    },
  });
}

/**
 * Get user's usage count for a discount
 */
export async function getUserDiscountUsageCount(
  discountId: string,
  userId: string
) {
  return prisma.discountUsage.count({
    where: {
      discountId,
      userId,
    },
  });
}

/**
 * Get total usage count for a discount
 */
export async function getDiscountTotalUsageCount(discountId: string) {
  return prisma.discountUsage.count({
    where: { discountId },
  });
}

/**
 * Record discount usage
 */
export async function recordDiscountUsage(
  discountId: string,
  orderId: string,
  userId?: string
) {
  return prisma.discountUsage.create({
    data: {
      discountId,
      orderId,
      userId,
    },
  });
}


================================================================================
FILE: dal/facet.dal.ts
================================================================================

import  prisma   from '@/lib/prisma';

export async function createFacet(
  storeId: string,
  data: {
    name: string;
    code: string;
  }
) {
  return prisma.facet.create({
    data: {
      storeId,
      name: data.name,
      code: data.code,
    },
    include: {
      values: true,
    },
  });
}

export async function createFacetValue(
  storeId: string,
  facetId: string,
  value: string
) {
  // Verify facet belongs to store
  const facet = await prisma.facet.findFirst({
    where: { id: facetId, storeId },
  });

  if (!facet) {
    throw new Error('Facet not found in this store');
  }

  return prisma.facetValue.create({
    data: {
      facetId,
      value,
    },
    include: {
      facet: true,
    },
  });
}

export async function listFacets(storeId: string) {
  return prisma.facet.findMany({
    where: { storeId },
    include: {
      values: true,
    },
    orderBy: { name: 'asc' },
  });
}

export async function getFacetById(storeId: string, facetId: string) {
  return prisma.facet.findFirst({
    where: {
      id: facetId,
      storeId,
    },
    include: {
      values: true,
    },
  });
}

export async function assignFacetValueToProduct(
  storeId: string,
  productId: string,
  facetValueId: string
) {
  // Verify product belongs to store
  const product = await prisma.product.findFirst({
    where: { id: productId, storeId },
  });

  if (!product) {
    throw new Error('Product not found');
  }

  // Verify facet value belongs to store (via facet)
  const facetValue = await prisma.facetValue.findFirst({
    where: {
      id: facetValueId,
      facet: {
        storeId,
      },
    },
  });

  if (!facetValue) {
    throw new Error('Facet value not found in this store');
  }

  return prisma.productFacetValue.create({
    data: {
      productId,
      facetValueId,
    },
  });
}

export async function assignFacetValueToVariant(
  storeId: string,
  variantId: string,
  facetValueId: string
) {
  // Verify variant belongs to store
  const variant = await prisma.productVariant.findFirst({
    where: {
      id: variantId,
      product: {
        storeId,
      },
    },
  });

  if (!variant) {
    throw new Error('Variant not found');
  }

  // Verify facet value belongs to store
  const facetValue = await prisma.facetValue.findFirst({
    where: {
      id: facetValueId,
      facet: {
        storeId,
      },
    },
  });

  if (!facetValue) {
    throw new Error('Facet value not found in this store');
  }

  return prisma.variantFacetValue.create({
    data: {
      variantId,
      facetValueId,
    },
  });
}

export async function deleteFacet(storeId: string, facetId: string) {
  // Verify facet belongs to store
  const facet = await prisma.facet.findFirst({
    where: { id: facetId, storeId },
  });

  if (!facet) {
    throw new Error('Facet not found');
  }

  return prisma.facet.delete({
    where: { id: facetId },
  });
}

export async function deleteFacetValue(
  storeId: string,
  facetValueId: string
) {
  // Verify facet value belongs to store
  const facetValue = await prisma.facetValue.findFirst({
    where: {
      id: facetValueId,
      facet: {
        storeId,
      },
    },
  });

  if (!facetValue) {
    throw new Error('Facet value not found');
  }

  return prisma.facetValue.delete({
    where: { id: facetValueId },
  });
}


================================================================================
FILE: dal/order.dal.ts
================================================================================

import   prisma   from '@/lib/prisma';
import { OrderStatus, Prisma } from '@/app/generated/prisma';

export async function createOrder(
  storeId: string,
  data: {
    userId?: string;
    total: number;
    status: OrderStatus;
    lines: Array<{
      variantId: string;
      quantity: number;
      price: number;
    }>;
  }
) {
  return prisma.order.create({
    data: {
      storeId,
      userId: data.userId,
      total: data.total,
      status: data.status,
      lines: {
        create: data.lines,
      },
    },
    include: {
      lines: {
        include: {
          variant: {
            include: {
              product: true,
            },
          },
        },
      },
      payments: true,
    },
  });
}

export async function getOrderById(storeId: string, orderId: string) {
  return prisma.order.findFirst({
    where: {
      id: orderId,
      storeId,
    },
    include: {
      lines: {
        include: {
          variant: {
            include: {
              product: true,
              images: true,
            },
          },
        },
      },
      payments: true,
    },
  });
}

export async function listOrders(
  storeId: string,
  filters?: {
    userId?: string;
    status?: OrderStatus;
    skip?: number;
    take?: number;
  }
) {
  const where: Prisma.OrderWhereInput = {
    storeId,
    ...(filters?.userId && { userId: filters.userId }),
    ...(filters?.status && { status: filters.status }),
  };

  const [orders, total] = await Promise.all([
    prisma.order.findMany({
      where,
      skip: filters?.skip ?? 0,
      take: filters?.take ?? 50,
      include: {
        lines: {
          include: {
            variant: {
              include: {
                product: true,
              },
            },
          },
        },
        payments: true,
      },
      orderBy: { createdAt: 'desc' },
    }),
    prisma.order.count({ where }),
  ]);

  return { orders, total };
}

export async function updateOrderStatus(
  storeId: string,
  orderId: string,
  status: OrderStatus
) {
  // Verify order belongs to store
  const order = await prisma.order.findFirst({
    where: { id: orderId, storeId },
  });

  if (!order) {
    throw new Error('Order not found');
  }

  return prisma.order.update({
    where: { id: orderId },
    data: { status },
    include: {
      lines: {
        include: {
          variant: {
            include: {
              product: true,
            },
          },
        },
      },
      payments: true,
    },
  });
}

export async function createOrderLine(
  storeId: string,
  orderId: string,
  data: {
    variantId: string;
    quantity: number;
    price: number;
  }
) {
  // Verify order belongs to store
  const order = await prisma.order.findFirst({
    where: { id: orderId, storeId },
  });

  if (!order) {
    throw new Error('Order not found');
  }

  // Verify variant belongs to store
  const variant = await prisma.productVariant.findFirst({
    where: {
      id: data.variantId,
      product: {
        storeId,
      },
    },
  });

  if (!variant) {
    throw new Error('Variant not found');
  }

  return prisma.orderLine.create({
    data: {
      orderId,
      variantId: data.variantId,
      quantity: data.quantity,
      price: data.price,
    },
    include: {
      variant: {
        include: {
          product: true,
        },
      },
    },
  });
}

export async function deleteOrder(storeId: string, orderId: string) {
  // Verify order belongs to store
  const order = await prisma.order.findFirst({
    where: { id: orderId, storeId },
  });

  if (!order) {
    throw new Error('Order not found');
  }

  return prisma.order.delete({
    where: { id: orderId },
  });
}


================================================================================
FILE: dal/paymentConfig.dal.ts
================================================================================

import prisma from '@/lib/prisma';
import { PaymentProvider } from '@/app/generated/prisma';
import { encrypt, decrypt } from '@/lib/utils/encryption';

/**
 * Create payment configuration
 */
export async function createPaymentConfig(
  storeId: string,
  data: {
    provider: PaymentProvider;
    apiKey: string;
    apiSecret?: string;
    webhookSecret?: string;
    isLive: boolean;
  }
) {
  return prisma.paymentConfig.create({
    data: {
      storeId,
      provider: data.provider,
      apiKey: encrypt(data.apiKey),
      apiSecret: data.apiSecret ? encrypt(data.apiSecret) : null,
      webhookSecret: data.webhookSecret ? encrypt(data.webhookSecret) : null,
      isLive: data.isLive,
    },
    select: {
      id: true,
      storeId: true,
      provider: true,
      isLive: true,
      isActive: true,
      createdAt: true,
      updatedAt: true,
    },
  });
}

/**
 * Update payment configuration
 */
export async function updatePaymentConfig(
  storeId: string,
  configId: string,
  data: {
    apiKey?: string;
    apiSecret?: string;
    webhookSecret?: string;
    isLive?: boolean;
    isActive?: boolean;
  }
) {
  const config = await prisma.paymentConfig.findFirst({
    where: { id: configId, storeId },
  });

  if (!config) {
    throw new Error('Payment config not found');
  }

  return prisma.paymentConfig.update({
    where: { id: configId },
    data: {
      ...(data.apiKey && { apiKey: encrypt(data.apiKey) }),
      ...(data.apiSecret && { apiSecret: encrypt(data.apiSecret) }),
      ...(data.webhookSecret && { webhookSecret: encrypt(data.webhookSecret) }),
      ...(data.isLive !== undefined && { isLive: data.isLive }),
      ...(data.isActive !== undefined && { isActive: data.isActive }),
    },
    select: {
      id: true,
      storeId: true,
      provider: true,
      isLive: true,
      isActive: true,
      createdAt: true,
      updatedAt: true,
    },
  });
}

/**
 * Delete payment configuration
 */
export async function deletePaymentConfig(storeId: string, configId: string) {
  const config = await prisma.paymentConfig.findFirst({
    where: { id: configId, storeId },
  });

  if (!config) {
    throw new Error('Payment config not found');
  }

  return prisma.paymentConfig.delete({
    where: { id: configId },
  });
}

/**
 * Get payment configuration (public data only)
 */
export async function getPaymentConfig(storeId: string, configId: string) {
  return prisma.paymentConfig.findFirst({
    where: {
      id: configId,
      storeId,
    },
    select: {
      id: true,
      storeId: true,
      provider: true,
      isLive: true,
      isActive: true,
      createdAt: true,
      updatedAt: true,
    },
  });
}

/**
 * Get decrypted credentials (INTERNAL USE ONLY)
 * NEVER expose via API
 */
export async function getPaymentCredentials(
  storeId: string,
  provider: PaymentProvider
) {
  const config = await prisma.paymentConfig.findFirst({
    where: {
      storeId,
      provider,
      isActive: true,
    },
  });

  if (!config) {
    throw new Error(`No active ${provider} configuration found`);
  }

  return {
    id: config.id,
    provider: config.provider,
    apiKey: decrypt(config.apiKey),
    apiSecret: config.apiSecret ? decrypt(config.apiSecret) : null,
    webhookSecret: config.webhookSecret ? decrypt(config.webhookSecret) : null,
    isLive: config.isLive,
  };
}

/**
 * List payment configurations
 */
export async function listPaymentConfigs(storeId: string) {
  return prisma.paymentConfig.findMany({
    where: { storeId },
    select: {
      id: true,
      provider: true,
      isLive: true,
      isActive: true,
      createdAt: true,
      updatedAt: true,
    },
    orderBy: { createdAt: 'desc' },
  });
}

/**
 * Get active payment config
 */
export async function getActivePaymentConfig(
  storeId: string,
  provider: PaymentProvider
) {
  return prisma.paymentConfig.findFirst({
    where: {
      storeId,
      provider,
      isActive: true,
    },
    select: {
      id: true,
      provider: true,
      isLive: true,
      isActive: true,
    },
  });
}


================================================================================
FILE: dal/payment.dal.ts
================================================================================

import prisma from '@/lib/prisma';
import { PaymentProvider, PaymentStatus } from '@/app/generated/prisma';

/**
 * Create payment record with idempotency
 */
export async function createPayment(
  storeId: string,
  orderId: string,
  data: {
    provider: PaymentProvider;
    amount: number;
    currency?: string;
    idempotencyKey?: string;
    providerPaymentId?: string;
  }
) {
  // Check for existing payment with same idempotency key
  if (data.idempotencyKey) {
    const existing = await prisma.payment.findUnique({
      where: { idempotencyKey: data.idempotencyKey },
    });

    if (existing) {
      return existing;
    }
  }

  return prisma.payment.create({
    data: {
      storeId,
      orderId,
      provider: data.provider,
      amount: data.amount,
      currency: data.currency || 'INR',
      idempotencyKey: data.idempotencyKey,
      providerPaymentId: data.providerPaymentId,
    },
  });
}

/**
 * Update payment status
 */
export async function updatePaymentStatus(
  storeId: string,
  paymentId: string,
  status: PaymentStatus,
  providerPaymentId?: string
) {
  return prisma.payment.update({
    where: {
      id: paymentId,
      storeId,
    },
    data: {
      status,
      ...(providerPaymentId && { providerPaymentId }),
    },
  });
}

/**
 * Get payment by ID
 */
export async function getPaymentById(storeId: string, paymentId: string) {
  return prisma.payment.findFirst({
    where: {
      id: paymentId,
      storeId,
    },
    include: {
      order: true,
    },
  });
}

/**
 * Get payment by provider payment ID
 */
export async function getPaymentByProviderId(
  storeId: string,
  providerPaymentId: string
) {
  return prisma.payment.findFirst({
    where: {
      storeId,
      providerPaymentId,
    },
    include: {
      order: true,
    },
  });
}

/**
 * List payments with filters
 */
export async function listPayments(
  storeId: string,
  filters?: {
    orderId?: string;
    status?: PaymentStatus;
    provider?: PaymentProvider;
    skip?: number;
    take?: number;
  }
) {
  const where: any = {
    storeId,
    ...(filters?.orderId && { orderId: filters.orderId }),
    ...(filters?.status && { status: filters.status }),
    ...(filters?.provider && { provider: filters.provider }),
  };

  const [payments, total] = await Promise.all([
    prisma.payment.findMany({
      where,
      skip: filters?.skip ?? 0,
      take: filters?.take ?? 50,
      include: {
        order: {
          select: {
            id: true,
            total: true,
            status: true,
            createdAt: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    }),
    prisma.payment.count({ where }),
  ]);

  return { payments, total };
}


================================================================================
FILE: dal/product.dal.ts
================================================================================

import prisma from '@/lib/prisma';
import { Prisma } from '@/app/generated/prisma';

/**
 * Create product
 */
export async function createProduct(
  storeId: string,
  data: {
    name: string;
    description?: string;
    categoryId?: string;
    isActive?: boolean;
  }
) {
  return prisma.product.create({
    data: {
      storeId,
      name: data.name,
      description: data.description,
      categoryId: data.categoryId,
      isActive: data.isActive ?? true,
    },
    include: {
      category: true,
      variants: {
        where: { deletedAt: null },
      },
      images: true,
    },
  });
}

/**
 * Update product
 */
export async function updateProduct(
  storeId: string,
  productId: string,
  data: {
    name?: string;
    description?: string;
    categoryId?: string;
    isActive?: boolean;
  }
) {
  return prisma.product.update({
    where: {
      id: productId,
      storeId,
      deletedAt: null,
    },
    data,
    include: {
      category: true,
      variants: {
        where: { deletedAt: null },
      },
      images: true,
    },
  });
}

/**
 * Soft delete product
 */
export async function deleteProduct(storeId: string, productId: string) {
  return prisma.product.update({
    where: {
      id: productId,
      storeId,
      deletedAt: null,
    },
    data: {
      deletedAt: new Date(),
      isActive: false,
    },
  });
}

/**
 * Get product by ID (excludes soft-deleted)
 */
export async function getProductById(storeId: string, productId: string) {
  return prisma.product.findFirst({
    where: {
      id: productId,
      storeId,
      deletedAt: null,
    },
    include: {
      category: {
        where: { deletedAt: null },
      },
      variants: {
        where: { deletedAt: null },
        include: {
          images: true,
          facets: {
            include: {
              facetValue: {
                include: {
                  facet: true,
                },
              },
            },
          },
        },
      },
      images: true,
      facets: {
        include: {
          facetValue: {
            include: {
              facet: true,
            },
          },
        },
      },
    },
  });
}

/**
 * List products with filters (excludes soft-deleted)
 */
export async function listProducts(
  storeId: string,
  filters?: {
    categoryId?: string;
    isActive?: boolean;
    search?: string;
    skip?: number;
    take?: number;
  }
) {
  const where: Prisma.ProductWhereInput = {
    storeId,
    deletedAt: null,
    ...(filters?.categoryId && { 
      categoryId: filters.categoryId,
      category: { deletedAt: null },
    }),
    ...(filters?.isActive !== undefined && { isActive: filters.isActive }),
    ...(filters?.search && {
      OR: [
        { name: { contains: filters.search, mode: 'insensitive' } },
        { description: { contains: filters.search, mode: 'insensitive' } },
      ],
    }),
  };

  const [products, total] = await Promise.all([
    prisma.product.findMany({
      where,
      skip: filters?.skip ?? 0,
      take: filters?.take ?? 50,
      include: {
        category: {
          where: { deletedAt: null },
        },
        variants: {
          where: { deletedAt: null },
          include: {
            images: true,
          },
        },
        images: true,
      },
      orderBy: { createdAt: 'desc' },
    }),
    prisma.product.count({ where }),
  ]);

  return { products, total };
}

/**
 * Attach category to product
 */
export async function attachCategory(
  storeId: string,
  productId: string,
  categoryId: string | null
) {
  return prisma.product.update({
    where: {
      id: productId,
      storeId,
      deletedAt: null,
    },
    data: {
      categoryId,
    },
  });
}

/**
 * Attach facet values to product
 */
export async function attachFacetValuesToProduct(
  storeId: string,
  productId: string,
  facetValueIds: string[]
) {
  const product = await prisma.product.findFirst({
    where: { id: productId, storeId, deletedAt: null },
  });

  if (!product) {
    throw new Error('Product not found');
  }

  // Delete existing facet values
  await prisma.productFacetValue.deleteMany({
    where: { productId },
  });

  // Create new associations
  if (facetValueIds.length > 0) {
    await prisma.productFacetValue.createMany({
      data: facetValueIds.map(facetValueId => ({
        productId,
        facetValueId,
      })),
    });
  }

  return prisma.product.findUnique({
    where: { id: productId },
    include: {
      facets: {
        include: {
          facetValue: {
            include: {
              facet: true,
            },
          },
        },
      },
    },
  });
}


================================================================================
FILE: dal/storestuff.dal.ts
================================================================================

import  prisma from '@/lib/prisma';
import { StoreRole } from '@/app/generated/prisma';

export async function addStoreStaff(
  storeId: string,
  userId: string,
  role: StoreRole
) {
  return prisma.storeStaff.create({
    data: {
      storeId,
      userId,
      role,
    },
    include: {
      user: {
        select: {
          id: true,
          email: true,
          name: true,
          image: true,
        },
      },
    },
  });
}

export async function updateStoreStaffRole(
  storeId: string,
  userId: string,
  role: StoreRole
) {
  return prisma.storeStaff.update({
    where: {
      storeId_userId: {
        storeId,
        userId,
      },
    },
    data: { role },
    include: {
      user: {
        select: {
          id: true,
          email: true,
          name: true,
          image: true,
        },
      },
    },
  });
}

export async function removeStoreStaff(storeId: string, userId: string) {
  return prisma.storeStaff.delete({
    where: {
      storeId_userId: {
        storeId,
        userId,
      },
    },
  });
}

export async function getStoreStaff(storeId: string, userId: string) {
  return prisma.storeStaff.findUnique({
    where: {
      storeId_userId: {
        storeId,
        userId,
      },
    },
    include: {
      user: {
        select: {
          id: true,
          email: true,
          name: true,
          image: true,
        },
      },
    },
  });
}

export async function listStoreStaff(storeId: string) {
  return prisma.storeStaff.findMany({
    where: { storeId },
    include: {
      user: {
        select: {
          id: true,
          email: true,
          name: true,
          image: true,
        },
      },
    },
    orderBy: { createdAt: 'desc' },
  });
}

export async function getUserStores(userId: string) {
  return prisma.storeStaff.findMany({
    where: { userId },
    include: {
      store: {
        select: {
          id: true,
          name: true,
          slug: true,
          plan: true,
        },
      },
    },
    orderBy: { createdAt: 'desc' },
  });
}

export async function countStoreOwners(storeId: string) {
  return prisma.storeStaff.count({
    where: {
      storeId,
      role: 'OWNER',
    },
  });
}

export async function isLastOwner(storeId: string, userId: string) {
  const staff = await prisma.storeStaff.findUnique({
    where: {
      storeId_userId: {
        storeId,
        userId,
      },
    },
  });

  if (!staff || staff.role !== 'OWNER') {
    return false;
  }

  const ownerCount = await countStoreOwners(storeId);
  return ownerCount === 1;
}


================================================================================
FILE: dal/subscription.dal.ts
================================================================================

import prisma from '@/lib/prisma';
import { PlanType, SubscriptionStatus, Prisma } from '@/app/generated/prisma';

/**
 * Create billing account
 */
export async function createAccount(name: string, ownerId: string) {
  return prisma.billingAccount.create({
    data: {
      name,
      users: {
        create: {
          userId: ownerId,
          role: 'OWNER',
        },
      },
    },
    include: {
      users: {
        include: {
          user: {
            select: {
              id: true,
              email: true,
              name: true,
            },
          },
        },
      },
    },
  });
}

/**
 * Get account by ID
 */
export async function getAccountById(accountId: string) {
  return prisma.billingAccount.findUnique({
    where: { id: accountId },
    include: {
      subscription: {
        include: {
          plan: true,
        },
      },
      users: {
        include: {
          user: {
            select: {
              id: true,
              email: true,
              name: true,
            },
          },
        },
      },
      stores: {
        select: {
          id: true,
          name: true,
          slug: true,
        },
      },
    },
  });
}

/**
 * Get account by user ID
 */
export async function getAccountByUserId(userId: string) {
  const accountUser = await prisma.accountUser.findFirst({
    where: { userId },
    include: {
      account: {
        include: {
          subscription: {
            include: {
              plan: true,
            },
          },
        },
      },
    },
    orderBy: { createdAt: 'asc' }, // Primary account
  });

  return accountUser?.account || null;
}

/**
 * Get account by store ID
 */
export async function getAccountByStoreId(storeId: string) {
  const store = await prisma.store.findUnique({
    where: { id: storeId },
    include: {
      account: {
        include: {
          subscription: {
            include: {
              plan: true,
            },
          },
        },
      },
    },
  });

  return store?.account || null;
}

/**
 * Create subscription plan
 */
export async function createPlan(data: {
  type: PlanType;
  name: string;
  description?: string;
  price: number;
  maxStores?: number;
  maxProducts?: number;
  maxOrdersPerMonth?: number;
  maxStaffMembers?: number;
  maxAPIRequestsPerMonth?: number;
}) {
  return prisma.subscriptionPlan.create({
    data,
  });
}

/**
 * Get plan by type
 */
export async function getPlanByType(type: PlanType) {
  return prisma.subscriptionPlan.findUnique({
    where: { type },
  });
}

/**
 * List all active plans
 */
export async function listActivePlans() {
  return prisma.subscriptionPlan.findMany({
    where: { isActive: true },
    orderBy: { price: 'asc' },
  });
}

/**
 * Create subscription for account
 */
export async function createSubscription(
  accountId: string,
  planId: string,
  startDate: Date
) {
  const endDate = new Date(startDate);
  endDate.setMonth(endDate.getMonth() + 1);

  return prisma.accountSubscription.create({
    data: {
      accountId,
      planId,
      status: 'ACTIVE',
      currentPeriodStart: startDate,
      currentPeriodEnd: endDate,
    },
    include: {
      plan: true,
      account: true,
    },
  });
}

/**
 * Get subscription by account ID
 */
export async function getSubscriptionByAccountId(accountId: string) {
  return prisma.accountSubscription.findUnique({
    where: { accountId },
    include: {
      plan: true,
      account: true,
    },
  });
}

/**
 * Update subscription status
 */
export async function updateSubscriptionStatus(
  accountId: string,
  status: SubscriptionStatus
) {
  return prisma.accountSubscription.update({
    where: { accountId },
    data: { status },
  });
}

/**
 * Renew subscription (advance period)
 */
export async function renewSubscription(accountId: string) {
  const subscription = await prisma.accountSubscription.findUnique({
    where: { accountId },
  });

  if (!subscription) {
    throw new Error('Subscription not found');
  }

  const newStart = subscription.currentPeriodEnd;
  const newEnd = new Date(newStart);
  newEnd.setMonth(newEnd.getMonth() + 1);

  return prisma.accountSubscription.update({
    where: { accountId },
    data: {
      currentPeriodStart: newStart,
      currentPeriodEnd: newEnd,
      status: 'ACTIVE',
    },
    include: {
      plan: true,
    },
  });
}

/**
 * Cancel subscription at period end
 */
export async function cancelSubscriptionAtPeriodEnd(accountId: string) {
  return prisma.accountSubscription.update({
    where: { accountId },
    data: {
      cancelAtPeriodEnd: true,
      canceledAt: new Date(),
    },
  });
}

/**
 * Change subscription plan
 */
export async function changeSubscriptionPlan(
  accountId: string,
  newPlanId: string
) {
  return prisma.accountSubscription.update({
    where: { accountId },
    data: {
      planId: newPlanId,
    },
    include: {
      plan: true,
    },
  });
}

/**
 * Get or create usage counter for current period
 */
export async function getOrCreateUsageCounter(accountId: string) {
  const subscription = await getSubscriptionByAccountId(accountId);

  if (!subscription) {
    throw new Error('No active subscription');
  }

  const periodStart = subscription.currentPeriodStart;
  const periodEnd = subscription.currentPeriodEnd;

  // Try to find existing counter
  let counter = await prisma.usageCounter.findUnique({
    where: {
      accountId_periodStart: {
        accountId,
        periodStart,
      },
    },
  });

  if (!counter) {
    // Create new counter for this period
    counter = await prisma.usageCounter.create({
      data: {
        accountId,
        periodStart,
        periodEnd,
      },
    });
  }

  return counter;
}

/**
 * Increment usage counter atomically
 */
export async function incrementUsage(
  accountId: string,
  field: 'storeCount' | 'productCount' | 'orderCount' | 'staffCount' | 'apiRequestCount',
  delta: number = 1
) {
  const counter = await getOrCreateUsageCounter(accountId);

  return prisma.usageCounter.update({
    where: { id: counter.id },
    data: {
      [field]: {
        increment: delta,
      },
    },
  });
}

/**
 * Decrement usage counter atomically
 */
export async function decrementUsage(
  accountId: string,
  field: 'storeCount' | 'productCount' | 'orderCount' | 'staffCount' | 'apiRequestCount',
  delta: number = 1
) {
  const counter = await getOrCreateUsageCounter(accountId);

  return prisma.usageCounter.update({
    where: { id: counter.id },
    data: {
      [field]: {
        decrement: delta,
      },
    },
  });
}

/**
 * Get current usage for account
 */
export async function getCurrentUsage(accountId: string) {
  const counter = await getOrCreateUsageCounter(accountId);
  return counter;
}

/**
 * Get total store count across all time (not just period)
 */
export async function getTotalStoreCount(accountId: string) {
  return prisma.store.count({
    where: { accountId },
  });
}

/**
 * Get total product count across all stores
 */
export async function getTotalProductCount(accountId: string) {
  return prisma.product.count({
    where: {
      store: {
        accountId,
      },
      deletedAt: null,
    },
  });
}

/**
 * Get total staff count across all stores
 */
export async function getTotalStaffCount(accountId: string) {
  return prisma.storeStaff.count({
    where: {
      store: {
        accountId,
      },
    },
  });
}

/**
 * Create invoice
 */
export async function createInvoice(
  accountId: string,
  amount: number,
  periodStart: Date,
  periodEnd: Date
) {
  return prisma.invoice.create({
    data: {
      accountId,
      amount,
      periodStart,
      periodEnd,
      status: 'PENDING',
    },
  });
}

/**
 * Mark invoice as paid
 */
export async function markInvoicePaid(invoiceId: string, paymentId: string) {
  return prisma.invoice.update({
    where: { id: invoiceId },
    data: {
      status: 'COMPLETED',
      paidAt: new Date(),
      paymentId,
    },
  });
}

/**
 * List subscriptions expiring soon (for renewal processing)
 */
export async function getSubscriptionsExpiringBefore(date: Date) {
  return prisma.accountSubscription.findMany({
    where: {
      currentPeriodEnd: {
        lte: date,
      },
      status: 'ACTIVE',
      cancelAtPeriodEnd: false,
    },
    include: {
      plan: true,
      account: true,
    },
  });
}

export async function GetInvoiceById(invoiceId: string) {
  return prisma.invoice.findUnique({
    where: { id: invoiceId },
  });
}


================================================================================
FILE: dal/varient.dal.ts
================================================================================

import prisma from '@/lib/prisma';

/**
 * Create variant
 */
export async function createVariant(
  storeId: string,
  productId: string,
  data: {
    sku: string;
    price: number;
    stock: number;
    isActive?: boolean;
  }
) {
  const product = await prisma.product.findFirst({
    where: { id: productId, storeId, deletedAt: null },
  });

  if (!product) {
    throw new Error('Product not found in this store');
  }

  return prisma.productVariant.create({
    data: {
      productId,
      sku: data.sku,
      price: data.price,
      stock: data.stock,
      isActive: data.isActive ?? true,
    },
    include: {
      product: true,
      images: true,
      facets: {
        include: {
          facetValue: {
            include: {
              facet: true,
            },
          },
        },
      },
    },
  });
}

/**
 * Update variant
 */
export async function updateVariant(
  storeId: string,
  variantId: string,
  data: {
    sku?: string;
    price?: number;
    stock?: number;
    isActive?: boolean;
  }
) {
  const variant = await prisma.productVariant.findFirst({
    where: {
      id: variantId,
      product: {
        storeId,
        deletedAt: null,
      },
      deletedAt: null,
    },
  });

  if (!variant) {
    throw new Error('Variant not found');
  }

  return prisma.productVariant.update({
    where: { id: variantId },
    data,
    include: {
      product: true,
      images: true,
      facets: {
        include: {
          facetValue: {
            include: {
              facet: true,
            },
          },
        },
      },
    },
  });
}

/**
 * Soft delete variant
 */
export async function deleteVariant(storeId: string, variantId: string) {
  const variant = await prisma.productVariant.findFirst({
    where: {
      id: variantId,
      product: {
        storeId,
      },
      deletedAt: null,
    },
  });

  if (!variant) {
    throw new Error('Variant not found');
  }

  return prisma.productVariant.update({
    where: { id: variantId },
    data: {
      deletedAt: new Date(),
      isActive: false,
    },
  });
}

/**
 * Get variant by ID (excludes soft-deleted)
 */
export async function getVariantById(storeId: string, variantId: string) {
  return prisma.productVariant.findFirst({
    where: {
      id: variantId,
      product: {
        storeId,
        deletedAt: null,
      },
      deletedAt: null,
    },
    include: {
      product: true,
      images: true,
      facets: {
        include: {
          facetValue: {
            include: {
              facet: true,
            },
          },
        },
      },
    },
  });
}

/**
 * Atomic stock update with race condition prevention
 * Uses conditional updateMany to ensure stock never goes negative
 * 
 * CRITICAL: This is the ONLY safe way to update stock under concurrency
 */
export async function updateStockAtomic(
  storeId: string,
  variantId: string,
  delta: number
) {
  const variant = await prisma.productVariant.findFirst({
    where: {
      id: variantId,
      product: {
        storeId,
        deletedAt: null,
      },
      deletedAt: null,
    },
    select: { id: true, stock: true },
  });

  if (!variant) {
    throw new Error('Variant not found');
  }

  // For decrements, prevent negative stock
  const minStock = delta < 0 ? Math.abs(delta) : 0;

  const updateResult = await prisma.productVariant.updateMany({
    where: {
      id: variantId,
      stock: { gte: minStock },
    },
    data: {
      stock: {
        increment: delta,
      },
    },
  });

  if (updateResult.count === 0) {
    throw new Error(
      `Insufficient stock. Available: ${variant.stock}, Requested: ${Math.abs(delta)}`
    );
  }

  return prisma.productVariant.findUnique({
    where: { id: variantId },
  });
}

/**
 * Attach facet values to variant
 */
export async function attachFacetValuesToVariant(
  storeId: string,
  variantId: string,
  facetValueIds: string[]
) {
  const variant = await prisma.productVariant.findFirst({
    where: {
      id: variantId,
      product: {
        storeId,
        deletedAt: null,
      },
      deletedAt: null,
    },
  });

  if (!variant) {
    throw new Error('Variant not found');
  }

  // Delete existing facet values
  await prisma.variantFacetValue.deleteMany({
    where: { variantId },
  });

  // Create new associations
  if (facetValueIds.length > 0) {
    await prisma.variantFacetValue.createMany({
      data: facetValueIds.map(facetValueId => ({
        variantId,
        facetValueId,
      })),
    });
  }

  return prisma.productVariant.findUnique({
    where: { id: variantId },
    include: {
      facets: {
        include: {
          facetValue: {
            include: {
              facet: true,
            },
          },
        },
      },
    },
  });
}


================================================================================
FILE: services/apiKey.service.ts
================================================================================

import * as apiKeyDal from '@/dal/apiKey.dal';
import { requireStoreRole, canManageApiKeys } from '@/lib/auth/requireStore';

const VALID_SCOPES = [
  '*',
  'products:read',
  'products:write',
  'orders:read',
  'orders:write',
  'categories:read',
  'categories:write',
];

export async function generateKey(
  userId: string,
  storeId: string,
  input: {
    name?: string;
    scopes: string[];
  }
) {
  // Permission check - only OWNER can create API keys
  const role = await requireStoreRole(userId, storeId, 'OWNER');
  
  if (!canManageApiKeys(role)) {
    throw new Error('Only store owners can manage API keys');
  }

  // Validation
  if (!input.scopes || input.scopes.length === 0) {
    throw new Error('At least one scope is required');
  }

  for (const scope of input.scopes) {
    if (!VALID_SCOPES.includes(scope)) {
      throw new Error(`Invalid scope: ${scope}`);
    }
  }

  if (input.name && input.name.length > 100) {
    throw new Error('Name must be 100 characters or less');
  }

  return apiKeyDal.createApiKey(storeId, input);
}

export async function revokeKey(
  userId: string,
  storeId: string,
  keyId: string
) {
  // Permission check - only OWNER can revoke API keys
  const role = await requireStoreRole(userId, storeId, 'OWNER');
  
  if (!canManageApiKeys(role)) {
    throw new Error('Only store owners can manage API keys');
  }

  return apiKeyDal.revokeApiKey(storeId, keyId);
}

export async function listKeys(userId: string, storeId: string) {
  // Permission check - only OWNER can view API keys
  const role = await requireStoreRole(userId, storeId, 'OWNER');
  
  if (!canManageApiKeys(role)) {
    throw new Error('Only store owners can view API keys');
  }

  return apiKeyDal.listApiKeys(storeId);
}

/**
 * Validates that an API key has required scopes.
 * Used in API routes to enforce scope-based permissions.
 */
export function validateScopes(keyScopes: string[], requiredScopes: string[]): void {
  if (keyScopes.includes('*')) {
    return; // Wildcard grants all scopes
  }

  for (const required of requiredScopes) {
    if (!keyScopes.includes(required)) {
      throw new Error(`Missing required scope: ${required}`);
    }
  }
}

export function hasReadScope(scopes: string[], resource: string): boolean {
  return scopes.includes('*') || scopes.includes(`${resource}:read`);
}

export function hasWriteScope(scopes: string[], resource: string): boolean {
  return scopes.includes('*') || scopes.includes(`${resource}:write`);
}


================================================================================
FILE: services/category.service.ts
================================================================================

import * as categoryDal from '@/dal/category.dal';
import { requireStoreRole } from '@/lib/auth/requireStore';

export async function createCategory(
  userId: string,
  storeId: string,
  input: {
    name: string;
    slug: string;
    parentId?: string;
  }
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'MANAGER');

  // Validation
  if (!input.name || input.name.trim().length === 0) {
    throw new Error('Category name is required');
  }

  if (!input.slug || input.slug.trim().length === 0) {
    throw new Error('Category slug is required');
  }

  // Slug validation (alphanumeric and hyphens only)
  if (!/^[a-z0-9-]+$/.test(input.slug)) {
    throw new Error('Slug must contain only lowercase letters, numbers, and hyphens');
  }

  if (input.name.length > 100) {
    throw new Error('Category name must be 100 characters or less');
  }

  return categoryDal.createCategory(storeId, input);
}

export async function updateCategory(
  userId: string,
  storeId: string,
  categoryId: string,
  input: {
    name?: string;
    slug?: string;
    parentId?: string;
  }
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'MANAGER');

  // Validation
  if (input.name !== undefined) {
    if (input.name.trim().length === 0) {
      throw new Error('Category name cannot be empty');
    }
    if (input.name.length > 100) {
      throw new Error('Category name must be 100 characters or less');
    }
  }

  if (input.slug !== undefined) {
    if (input.slug.trim().length === 0) {
      throw new Error('Category slug cannot be empty');
    }
    if (!/^[a-z0-9-]+$/.test(input.slug)) {
      throw new Error('Slug must contain only lowercase letters, numbers, and hyphens');
    }
  }

  return categoryDal.updateCategory(storeId, categoryId, input);
}

export async function deleteCategory(
  userId: string,
  storeId: string,
  categoryId: string
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'MANAGER');

  return categoryDal.deleteCategory(storeId, categoryId);
}

export async function listCategories(storeId: string) {
  // Public read access
  return categoryDal.listCategories(storeId);
}

export async function getCategoryTree(storeId: string) {
  // Public read access
  return categoryDal.getCategoryTree(storeId);
}

export async function getCategory(storeId: string, categoryId: string) {
  // Public read access
  return categoryDal.getCategoryById(storeId, categoryId);
}


================================================================================
FILE: services/discount.service.ts
================================================================================

import * as discountDal from '@/dal/discount.dal';
import { requireStoreRole } from '@/lib/auth/requireStore';
import { DiscountType, DiscountScope } from '@/app/generated/prisma';

interface DiscountInput {
  code?: string;
  name: string;
  description?: string;
  type: DiscountType;
  value: number;
  scope: DiscountScope;
  startsAt: Date | string;
  endsAt: Date | string;
  maxUsageCount?: number;
  maxUsagePerUser?: number;
  minOrderValue?: number;
  isStackable?: boolean;
  productIds?: string[];
  categoryIds?: string[];
}

export async function createDiscount(
  userId: string,
  storeId: string,
  input: DiscountInput
) {
  // Permission check - OWNER or MANAGER only
  await requireStoreRole(userId, storeId, 'MANAGER');

  // Validation
  if (!input.name || input.name.trim().length === 0) {
    throw new Error('Discount name is required');
  }

  if (input.code && input.code.trim().length === 0) {
    throw new Error('Discount code cannot be empty');
  }

  if (input.code && input.code.length > 50) {
    throw new Error('Discount code must be 50 characters or less');
  }

  if (input.value <= 0) {
    throw new Error('Discount value must be positive');
  }

  if (input.type === 'PERCENTAGE' && input.value > 10000) {
    throw new Error('Percentage discount cannot exceed 100%');
  }

  const startsAt = new Date(input.startsAt);
  const endsAt = new Date(input.endsAt);

  if (isNaN(startsAt.getTime())) {
    throw new Error('Invalid start date');
  }

  if (isNaN(endsAt.getTime())) {
    throw new Error('Invalid end date');
  }

  if (endsAt <= startsAt) {
    throw new Error('End date must be after start date');
  }

  if (input.maxUsageCount !== undefined && input.maxUsageCount <= 0) {
    throw new Error('Max usage count must be positive');
  }

  if (input.maxUsagePerUser !== undefined && input.maxUsagePerUser <= 0) {
    throw new Error('Max usage per user must be positive');
  }

  if (input.minOrderValue !== undefined && input.minOrderValue < 0) {
    throw new Error('Min order value cannot be negative');
  }

  // Validate scope-specific requirements
  if (input.scope === 'PRODUCT' && (!input.productIds || input.productIds.length === 0)) {
    throw new Error('Product-specific discounts require at least one product');
  }

  if (input.scope === 'CATEGORY' && (!input.categoryIds || input.categoryIds.length === 0)) {
    throw new Error('Category-specific discounts require at least one category');
  }

  return discountDal.createDiscount(storeId, {
    code: input.code,
    name: input.name,
    description: input.description,
    type: input.type,
    value: input.value,
    scope: input.scope,
    startsAt,
    endsAt,
    maxUsageCount: input.maxUsageCount,
    maxUsagePerUser: input.maxUsagePerUser,
    minOrderValue: input.minOrderValue,
    isStackable: input.isStackable ?? false,
    productIds: input.productIds,
    categoryIds: input.categoryIds,
  });
}

export async function updateDiscount(
  userId: string,
  storeId: string,
  discountId: string,
  input: Partial<DiscountInput> & { isActive?: boolean }
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'MANAGER');

  // Validation
  if (input.name !== undefined && input.name.trim().length === 0) {
    throw new Error('Discount name cannot be empty');
  }

  if (input.code !== undefined && input.code.trim().length === 0) {
    throw new Error('Discount code cannot be empty');
  }

  if (input.value !== undefined && input.value <= 0) {
    throw new Error('Discount value must be positive');
  }

  if (input.type === 'PERCENTAGE' && input.value !== undefined && input.value > 10000) {
    throw new Error('Percentage discount cannot exceed 100%');
  }

  let startsAt: Date | undefined;
  let endsAt: Date | undefined;

  if (input.startsAt) {
    startsAt = new Date(input.startsAt);
    if (isNaN(startsAt.getTime())) {
      throw new Error('Invalid start date');
    }
  }

  if (input.endsAt) {
    endsAt = new Date(input.endsAt);
    if (isNaN(endsAt.getTime())) {
      throw new Error('Invalid end date');
    }
  }

  // If both dates provided, validate
  if (startsAt && endsAt && endsAt <= startsAt) {
    throw new Error('End date must be after start date');
  }

  return discountDal.updateDiscount(storeId, discountId, {
    code: input.code,
    name: input.name,
    description: input.description,
    value: input.value,
    startsAt,
    endsAt,
    maxUsageCount: input.maxUsageCount,
    maxUsagePerUser: input.maxUsagePerUser,
    minOrderValue: input.minOrderValue,
    isStackable: input.isStackable,
    isActive: input.isActive,
    productIds: input.productIds,
    categoryIds: input.categoryIds,
  });
}

export async function deleteDiscount(
  userId: string,
  storeId: string,
  discountId: string
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'MANAGER');

  return discountDal.deleteDiscount(storeId, discountId);
}

export async function getDiscount(
  userId: string,
  storeId: string,
  discountId: string
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'SUPPORT');

  return discountDal.getDiscountById(storeId, discountId);
}

export async function listDiscounts(
  userId: string,
  storeId: string,
  filters?: {
    isActive?: boolean;
    scope?: DiscountScope;
    skip?: number;
    take?: number;
  }
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'SUPPORT');

  const take = filters?.take ?? 50;
  if (take > 100) {
    throw new Error('Maximum 100 items per page');
  }

  return discountDal.listDiscounts(storeId, {
    ...filters,
    take,
  });
}

/**
 * Calculate discount for order items (SERVICE LAYER ONLY)
 * Returns applicable discounts and total discount amount
 */
export interface OrderItem {
  variantId: string;
  productId: string;
  categoryId: string | null;
  quantity: number;
  price: number;
}

export interface ApplicableDiscount {
  id: string;
  code: string | null;
  name: string;
  type: DiscountType;
  value: number;
  scope: DiscountScope;
  amount: number; // Calculated discount amount
}

export async function calculateDiscounts(
  storeId: string,
  items: OrderItem[],
  subtotal: number,
  userId?: string,
  couponCode?: string
): Promise<{
  applicableDiscounts: ApplicableDiscount[];
  totalDiscount: number;
}> {
  const now = new Date();

  // Get all applicable discounts (time-constrained, active)
  let discounts = await discountDal.getApplicableDiscounts(storeId, now);

  // Filter by coupon code if provided
  if (couponCode) {
    const couponDiscount = discounts.find(
      d => d.code && d.code.toUpperCase() === couponCode.toUpperCase()
    );
    if (!couponDiscount) {
      throw new Error('Invalid or expired coupon code');
    }
    // Only consider this discount if code provided
    discounts = [couponDiscount];
  } else {
    // Filter out discounts that require a code
    discounts = discounts.filter(d => !d.code);
  }

  const applicableDiscounts: ApplicableDiscount[] = [];

  for (const discount of discounts) {
    // Check min order value
    if (discount.minOrderValue && subtotal < discount.minOrderValue) {
      continue;
    }

    // Check total usage limit
    if (discount.maxUsageCount) {
      const totalUsage = await discountDal.getDiscountTotalUsageCount(discount.id);
      if (totalUsage >= discount.maxUsageCount) {
        continue;
      }
    }

    // Check per-user usage limit
    if (discount.maxUsagePerUser && userId) {
      const userUsage = await discountDal.getUserDiscountUsageCount(discount.id, userId);
      if (userUsage >= discount.maxUsagePerUser) {
        continue;
      }
    }

    // Calculate discount amount based on scope
    let discountAmount = 0;

    switch (discount.scope) {
      case 'STORE_WIDE':
        discountAmount = calculateDiscountAmount(discount.type, discount.value, subtotal);
        break;

      case 'CATEGORY':
        const categoryIds = discount.categories.map(c => c.categoryId);
        const categorySubtotal = items
          .filter(item => item.categoryId && categoryIds.includes(item.categoryId))
          .reduce((sum, item) => sum + item.price * item.quantity, 0);
        discountAmount = calculateDiscountAmount(discount.type, discount.value, categorySubtotal);
        break;

      case 'PRODUCT':
        const productIds = discount.products.map(p => p.productId);
        const productSubtotal = items
          .filter(item => productIds.includes(item.productId))
          .reduce((sum, item) => sum + item.price * item.quantity, 0);
        discountAmount = calculateDiscountAmount(discount.type, discount.value, productSubtotal);
        break;
    }

    if (discountAmount > 0) {
      applicableDiscounts.push({
        id: discount.id,
        code: discount.code,
        name: discount.name,
        type: discount.type,
        value: discount.value,
        scope: discount.scope,
        amount: discountAmount,
      });
    }
  }

  // Apply stacking rules
  let totalDiscount = 0;

  if (applicableDiscounts.length === 0) {
    return { applicableDiscounts: [], totalDiscount: 0 };
  }

  if (applicableDiscounts.length === 1) {
    totalDiscount = applicableDiscounts[0].amount;
  } else {
    // Check if all discounts are stackable
    const allStackable = applicableDiscounts.every(d => {
      const original = discounts.find(od => od.id === d.id);
      return original?.isStackable;
    });

    if (allStackable) {
      // Stack all discounts
      totalDiscount = applicableDiscounts.reduce((sum, d) => sum + d.amount, 0);
    } else {
      // Use best discount only
      const bestDiscount = applicableDiscounts.reduce((best, current) =>
        current.amount > best.amount ? current : best
      );
      applicableDiscounts = [bestDiscount];
      totalDiscount = bestDiscount.amount;
    }
  }

  // Ensure discount doesn't exceed subtotal
  if (totalDiscount > subtotal) {
    totalDiscount = subtotal;
  }

  return { applicableDiscounts, totalDiscount };
}

/**
 * Helper to calculate discount amount
 */
function calculateDiscountAmount(
  type: DiscountType,
  value: number,
  amount: number
): number {
  if (type === 'PERCENTAGE') {
    // value is stored as basis points (e.g., 1000 = 10%)
    return Math.floor((amount * value) / 10000);
  } else {
    // FIXED_AMOUNT - value is in paise
    return Math.min(value, amount);
  }
}


================================================================================
FILE: services/order.service.ts
================================================================================

import prisma from '@/lib/prisma';
import * as discountDal from '@/dal/discount.dal';
import * as subscriptionDal from '@/dal/subscription.dal';
import * as usageService from '@/services/usage.service';
import { requireStoreRole } from '@/lib/auth/requireStore';
import { OrderStatus } from '@/app/generated/prisma';
import * as discountService from '@/services/discount.service';
import {
  NotFoundError,
  ValidationError,
  ConflictError,
} from '@/lib/errors';

interface OrderLineInput {
  variantId: string;
  quantity: number;
}

 
export async function createOrder(
  storeId: string,
  input: {
    userId?: string;
    lines: OrderLineInput[];
    currency?: string;
  },
  couponCode?: string
) {
  // GET ACCOUNT FROM STORE
  const account = await subscriptionDal.getAccountByStoreId(storeId);
  if (!account) {
    throw new NotFoundError('Store account');
  }

  // ENFORCE ORDER LIMIT (account-wide, monthly)
 

  // Validation
  if (!input.lines || input.lines.length === 0) {
    throw new ValidationError('Order must have at least one line item');
  }

  if (input.lines.length > 100) {
    throw new ValidationError('Maximum 100 line items per order');
  }

  for (const line of input.lines) {
    if (line.quantity <= 0) {
      throw new ValidationError('Quantity must be positive');
    }

    if (!Number.isInteger(line.quantity)) {
      throw new ValidationError('Quantity must be a whole number');
    }

    if (line.quantity > 1000) {
      throw new ValidationError('Maximum quantity per item is 1000');
    }
  }

  const currency = input.currency || 'INR';

  // ==========================================
  // STEP 1: PRE-TRANSACTION PREPARATION
  // Fetch variants and calculate totals OUTSIDE transaction
  // ==========================================
  
  const variantIds = input.lines.map(l => l.variantId);
  const variants = await prisma.productVariant.findMany({
    where: {
      id: { in: variantIds },
      product: { storeId, deletedAt: null },
      deletedAt: null,
    },
    include: {
      product: {
        select: {
          id: true,
          categoryId: true,
          isActive: true,
          deletedAt: true,
        },
      },
    },
  });

  if (variants.length !== variantIds.length) {
    const foundIds = new Set(variants.map(v => v.id));
    const missingIds = variantIds.filter(id => !foundIds.has(id));
    throw new NotFoundError(`Variants: ${missingIds.join(', ')}`);
  }

  // Validate variants and calculate subtotal
  const processedLines: Array<{
    variantId: string;
    productId: string;
    categoryId: string | null;
    quantity: number;
    price: number;
  }> = [];

  let subtotal = 0;

  for (const line of input.lines) {
    const variant = variants.find(v => v.id === line.variantId);
    if (!variant) {
      throw new NotFoundError(`Variant ${line.variantId}`);
    }

    if (!variant.isActive) {
      throw new ConflictError(`Variant ${variant.sku} is not active`);
    }

    if (!variant.product.isActive) {
      throw new ConflictError(`Product for variant ${variant.sku} is not active`);
    }

    if (variant.product.deletedAt) {
      throw new ConflictError(`Product for variant ${variant.sku} has been deleted`);
    }

    if (variant.stock < line.quantity) {
      throw new ConflictError(
        `Insufficient stock for ${variant.sku}. Available: ${variant.stock}, Requested: ${line.quantity}`
      );
    }

    const lineTotal = variant.price * line.quantity;
    subtotal += lineTotal;

    processedLines.push({
      variantId: line.variantId,
      productId: variant.product.id,
      categoryId: variant.product.categoryId,
      quantity: line.quantity,
      price: variant.price,
    });
  }

  // ==========================================
  // STEP 2: CALCULATE DISCOUNTS (OUTSIDE TRANSACTION)
  // This is the critical optimization - no locks held during calculation
  // ==========================================
  
  const { applicableDiscounts, totalDiscount } = await discountService.calculateDiscounts(
    storeId,
    processedLines,
    subtotal,
    input.userId,
    couponCode
  );

  // Calculate final total (clamped >= 0)
  const finalTotal = Math.max(0, subtotal - totalDiscount);

  // ==========================================
  // STEP 3: ATOMIC TRANSACTION (MINIMAL LOCK TIME)
  // Only stock updates and order creation inside transaction
  // ==========================================
  
  const order = await prisma.$transaction(async (tx) => {
    // Reserve stock atomically with conditional updates
    for (const line of processedLines) {
      const updateResult = await tx.productVariant.updateMany({
        where: {
          id: line.variantId,
          stock: { gte: line.quantity },
          deletedAt: null,
        },
        data: {
          stock: {
            decrement: line.quantity,
          },
        },
      });

      if (updateResult.count === 0) {
        throw new ConflictError(
          `Insufficient stock for variant ${line.variantId} (race condition detected)`
        );
      }
    }

    // Create order with immutable snapshot
    const order = await tx.order.create({
      data: {
        storeId,
        userId: input.userId,
        subtotal,
        discountAmount: totalDiscount,
        total: finalTotal,
        currency,
        status: 'PENDING',
        lines: {
          create: processedLines.map(line => ({
            variantId: line.variantId,
            quantity: line.quantity,
            price: line.price,
          })),
        },
        discounts: applicableDiscounts.length > 0 ? {
          create: applicableDiscounts.map(discount => ({
            discountId: discount.id,
            amount: discount.amount,
          })),
        } : undefined,
      },
      include: {
        lines: {
          include: {
            variant: {
              include: {
                product: true,
              },
            },
          },
        },
        discounts: {
          include: {
            discount: true,
          },
        },
        payments: true,
      },
    });

    // Record discount usage
    for (const discount of applicableDiscounts) {
      await discountDal.recordDiscountUsage(discount.id, order.id, input.userId);
    }

    return order;
  }, {
    timeout: 10000,
    maxWait: 5000,
  });

  // RECORD ORDER CREATION (after transaction completes)
  await usageService.recordOrderCreation(account.id);

  return order;
}

/**
 * Get order by ID
 */
export async function getOrder(
  userId: string,
  storeId: string,
  orderId: string
) {
  await requireStoreRole(userId, storeId, 'SUPPORT');

  const order = await prisma.order.findFirst({
    where: {
      id: orderId,
      storeId,
    },
    include: {
      lines: {
        include: {
          variant: {
            include: {
              product: true,
              images: true,
            },
          },
        },
      },
      discounts: {
        include: {
          discount: true,
        },
      },
      payments: true,
    },
  });

  if (!order) {
    throw new NotFoundError('Order');
  }

  return order;
}

/**
 * List orders with filters
 */
export async function listOrders(
  userId: string,
  storeId: string,
  filters?: {
    userId?: string;
    status?: OrderStatus;
    skip?: number;
    take?: number;
  }
) {
  await requireStoreRole(userId, storeId, 'SUPPORT');

  const take = filters?.take ?? 50;
  if (take > 100) {
    throw new ValidationError('Maximum 100 items per page');
  }

  const where = {
    storeId,
    ...(filters?.userId && { userId: filters.userId }),
    ...(filters?.status && { status: filters.status }),
  };

  const [orders, total] = await Promise.all([
    prisma.order.findMany({
      where,
      skip: filters?.skip ?? 0,
      take,
      include: {
        lines: {
          include: {
            variant: {
              include: {
                product: true,
              },
            },
          },
        },
        discounts: {
          include: {
            discount: true,
          },
        },
        payments: true,
      },
      orderBy: { createdAt: 'desc' },
    }),
    prisma.order.count({ where }),
  ]);

  return { orders, total };
}

/**
 * Update order status with stock restoration
 */
export async function updateOrderStatus(
  userId: string,
  storeId: string,
  orderId: string,
  status: OrderStatus
) {
  await requireStoreRole(userId, storeId, 'MANAGER');

  return prisma.$transaction(async (tx) => {
    const order = await tx.order.findFirst({
      where: { id: orderId, storeId },
      include: {
        lines: true,
      },
    });

    if (!order) {
      throw new NotFoundError('Order');
    }

    // Business rules
    if (order.status === 'CANCELLED' && status !== 'CANCELLED') {
      throw new ConflictError('Cannot change status of cancelled order');
    }

    if (order.status === 'REFUNDED' && status !== 'REFUNDED') {
      throw new ConflictError('Cannot change status of refunded order');
    }

    if (order.status === 'PAID' && status === 'PENDING') {
      throw new ConflictError('Cannot revert paid order to pending');
    }

    // Restore stock if cancelling or refunding
    if ((status === 'CANCELLED' || status === 'REFUNDED') && 
        (order.status !== 'CANCELLED' && order.status !== 'REFUNDED')) {
      for (const line of order.lines) {
        await tx.productVariant.update({
          where: { id: line.variantId },
          data: {
            stock: {
              increment: line.quantity,
            },
          },
        });
      }
    }

    return tx.order.update({
      where: { id: orderId },
      data: { status },
      include: {
        lines: {
          include: {
            variant: {
              include: {
                product: true,
              },
            },
          },
        },
        discounts: {
          include: {
            discount: true,
          },
        },
        payments: true,
      },
    });
  });
}


================================================================================
FILE: services/paymentConfig.service.ts
================================================================================

import * as paymentConfigDal from '@/dal/paymentConfig.dal';
import { requireStoreRole, canManageApiKeys } from '@/lib/auth/requireStore';
import { PaymentProvider } from '@/app/generated/prisma';

export async function createPaymentConfig(
  userId: string,
  storeId: string,
  input: {
    provider: PaymentProvider;
    apiKey: string;
    apiSecret?: string;
    webhookSecret?: string;
    isLive: boolean;
  }
) {
  // Only OWNER can manage payment configurations
  const role = await requireStoreRole(userId, storeId, 'OWNER');
  
  if (!canManageApiKeys(role)) {
    throw new Error('Only store owners can manage payment configurations');
  }

  // Validation
  if (!input.apiKey || input.apiKey.trim().length === 0) {
    throw new Error('API key is required');
  }

  // Validate provider-specific requirements
  switch (input.provider) {
    case 'STRIPE':
      if (!input.apiKey.startsWith('sk_') && !input.apiKey.startsWith('rk_')) {
        throw new Error('Invalid Stripe API key format');
      }
      if (!input.webhookSecret) {
        throw new Error('Webhook secret is required for Stripe');
      }
      break;
    
    case 'RAZORPAY':
      if (!input.apiSecret) {
        throw new Error('API secret is required for Razorpay');
      }
      break;
    
    case 'MANUAL':
      // No specific validation for manual payments
      break;
  }

  return paymentConfigDal.createPaymentConfig(storeId, input);
}

export async function updatePaymentConfig(
  userId: string,
  storeId: string,
  configId: string,
  input: {
    apiKey?: string;
    apiSecret?: string;
    webhookSecret?: string;
    isLive?: boolean;
    isActive?: boolean;
  }
) {
  // Only OWNER can manage payment configurations
  const role = await requireStoreRole(userId, storeId, 'OWNER');
  
  if (!canManageApiKeys(role)) {
    throw new Error('Only store owners can manage payment configurations');
  }

  // Validation
  if (input.apiKey !== undefined && input.apiKey.trim().length === 0) {
    throw new Error('API key cannot be empty');
  }

  return paymentConfigDal.updatePaymentConfig(storeId, configId, input);
}

export async function deletePaymentConfig(
  userId: string,
  storeId: string,
  configId: string
) {
  // Only OWNER can manage payment configurations
  const role = await requireStoreRole(userId, storeId, 'OWNER');
  
  if (!canManageApiKeys(role)) {
    throw new Error('Only store owners can manage payment configurations');
  }

  return paymentConfigDal.deletePaymentConfig(storeId, configId);
}

export async function listPaymentConfigs(
  userId: string,
  storeId: string
) {
  // Only OWNER can view payment configurations
  const role = await requireStoreRole(userId, storeId, 'OWNER');
  
  if (!canManageApiKeys(role)) {
    throw new Error('Only store owners can view payment configurations');
  }

  return paymentConfigDal.listPaymentConfigs(storeId);
}

export async function getPaymentConfig(
  userId: string,
  storeId: string,
  configId: string
) {
  // Only OWNER can view payment configurations
  const role = await requireStoreRole(userId, storeId, 'OWNER');
  
  if (!canManageApiKeys(role)) {
    throw new Error('Only store owners can view payment configurations');
  }

  return paymentConfigDal.getPaymentConfig(storeId, configId);
}


================================================================================
FILE: services/payment.service.ts
================================================================================

import * as paymentDal from '@/dal/payment.dal';
import * as orderDal from '@/dal/order.dal';
import { requireStoreRole } from '@/lib/auth/requireStore';
import { PaymentProvider, PaymentStatus } from '@/app/generated/prisma';

export async function createPayment(
  userId: string,
  storeId: string,
  orderId: string,
  input: {
    provider: PaymentProvider;
    amount: number;
    currency?: string;
  }
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'MANAGER');

  // Validation
  if (input.amount <= 0) {
    throw new Error('Payment amount must be positive');
  }

  if (!Number.isInteger(input.amount)) {
    throw new Error('Payment amount must be in smallest currency unit');
  }

  // Verify order exists and belongs to store
  const order = await orderDal.getOrderById(storeId, orderId);
  if (!order) {
    throw new Error('Order not found');
  }

  // Business rule: Can't create payment for cancelled order
  if (order.status === 'CANCELLED') {
    throw new Error('Cannot create payment for cancelled order');
  }

  return paymentDal.createPayment(storeId, orderId, {
    provider: input.provider,
    amount: input.amount,
    currency: input.currency,
  });
}

export async function updatePaymentStatus(
  userId: string,
  storeId: string,
  paymentId: string,
  status: PaymentStatus
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'MANAGER');

  // Get payment to check current status
  const payment = await paymentDal.getPaymentById(storeId, paymentId);
  if (!payment) {
    throw new Error('Payment not found');
  }

  // Business rules for status transitions
  if (payment.status === 'COMPLETED') {
    throw new Error('Cannot change status of completed payment');
  }

  // Update payment status
  const updatedPayment = await paymentDal.updatePaymentStatus(
    storeId,
    paymentId,
    status
  );

  // If payment completed, update order status
  if (status === 'COMPLETED') {
    await orderDal.updateOrderStatus(storeId, payment.orderId, 'PAID');
  }

  return updatedPayment;
}

export async function getPayment(
  userId: string,
  storeId: string,
  paymentId: string
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'SUPPORT');

  return paymentDal.getPaymentById(storeId, paymentId);
}

export async function listPayments(
  userId: string,
  storeId: string,
  filters?: {
    orderId?: string;
    status?: PaymentStatus;
    provider?: PaymentProvider;
    skip?: number;
    take?: number;
  }
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'SUPPORT');

  // Validation
  const take = filters?.take ?? 50;
  if (take > 100) {
    throw new Error('Maximum 100 items per page');
  }

  return paymentDal.listPayments(storeId, {
    ...filters,
    take,
  });
}


================================================================================
FILE: services/product.service.ts
================================================================================

import * as productDal from '@/dal/product.dal';
import * as subscriptionDal from '@/dal/subscription.dal';
import * as usageService from '@/services/usage.service';
import { requireStoreRole } from '@/lib/auth/requireStore';

export async function createProduct(
  userId: string,
  storeId: string,
  input: {
    name: string;
    description?: string;
    categoryId?: string;
    isActive?: boolean;
  }
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'MANAGER');

  // GET ACCOUNT FROM STORE
  const account = await subscriptionDal.getAccountByStoreId(storeId);
  if (!account) {
    throw new Error('Store does not belong to any account');
  }

  // ENFORCE PRODUCT LIMIT (account-wide)
  await usageService.checkProductLimit(account.id);

  // Validation
  if (!input.name || input.name.trim().length === 0) {
    throw new Error('Product name is required');
  }

  if (input.name.length > 200) {
    throw new Error('Product name must be 200 characters or less');
  }

  const product = await productDal.createProduct(storeId, input);

  // RECORD PRODUCT CREATION
  await usageService.recordProductCreation(account.id);

  return product;
}

export async function updateProduct(
  userId: string,
  storeId: string,
  productId: string,
  input: {
    name?: string;
    description?: string;
    categoryId?: string;
    isActive?: boolean;
  }
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'MANAGER');

  // Validation
  if (input.name !== undefined) {
    if (input.name.trim().length === 0) {
      throw new Error('Product name cannot be empty');
    }
    if (input.name.length > 200) {
      throw new Error('Product name must be 200 characters or less');
    }
  }

  return productDal.updateProduct(storeId, productId, input);
}

export async function deleteProduct(
  userId: string,
  storeId: string,
  productId: string
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'MANAGER');

  const product = await productDal.deleteProduct(storeId, productId);

  // GET ACCOUNT FROM STORE
  const account = await subscriptionDal.getAccountByStoreId(storeId);
  if (account) {
    // RECORD PRODUCT DELETION
    await usageService.recordProductDeletion(account.id);
  }

  return product;
}

export async function getProduct(storeId: string, productId: string) {
  // Read access - no permission check needed (public API)
  return productDal.getProductById(storeId, productId);
}

export async function listProducts(
  storeId: string,
  filters?: {
    categoryId?: string;
    isActive?: boolean;
    search?: string;
    skip?: number;
    take?: number;
  }
) {
  // Read access - no permission check needed (public API)
  
  // Validation
  const take = filters?.take ?? 50;
  if (take > 100) {
    throw new Error('Maximum 100 items per page');
  }

  return productDal.listProducts(storeId, {
    ...filters,
    take,
  });
}

export async function attachCategoryToProduct(
  userId: string,
  storeId: string,
  productId: string,
  categoryId: string | null
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'MANAGER');

  return productDal.attachCategory(storeId, productId, categoryId);
}

export async function attachFacetsToProduct(
  userId: string,
  storeId: string,
  productId: string,
  facetValueIds: string[]
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'MANAGER');

  return productDal.attachFacetValuesToProduct(storeId, productId, facetValueIds);
}


================================================================================
FILE: services/store.service.ts
================================================================================

import prisma from '@/lib/prisma';
import * as subscriptionDal from '@/dal/subscription.dal';
import * as usageService from '@/services/usage.service';

/**
 * Create new store
 */
export async function createStore(
  userId: string,
  input: {
    name: string;
    slug: string;
  }
) {
  // Get user's account
  const account = await subscriptionDal.getAccountByUserId(userId);

  if (!account) {
    throw new Error('User does not have a billing account');
  }

  // ENFORCE STORE LIMIT
  await usageService.checkStoreLimit(account.id);

  // Validation
  if (!input.name || input.name.trim().length === 0) {
    throw new Error('Store name is required');
  }

  if (!input.slug || input.slug.trim().length === 0) {
    throw new Error('Store slug is required');
  }

  // Slug validation (alphanumeric and hyphens only)
  if (!/^[a-z0-9-]+$/.test(input.slug)) {
    throw new Error('Slug must contain only lowercase letters, numbers, and hyphens');
  }

  // Check slug uniqueness
  const existingStore = await prisma.store.findUnique({
    where: { slug: input.slug },
  });

  if (existingStore) {
    throw new Error('Store slug already exists');
  }

  // Create store and assign user as OWNER
  const store = await prisma.$transaction(async (tx) => {
    const newStore = await tx.store.create({
      data: {
        accountId: account.id,
        name: input.name,
        slug: input.slug,
      },
    });

    // Add user as store owner
    await tx.storeStaff.create({
      data: {
        storeId: newStore.id,
        userId,
        role: 'OWNER',
      },
    });

    return newStore;
  });

  // RECORD STORE CREATION
  await usageService.recordStoreCreation(account.id);

  return store;
}

/**
 * Delete store
 */
export async function deleteStore(userId: string, storeId: string) {
  // Verify user is OWNER of the store
  const storeStaff = await prisma.storeStaff.findUnique({
    where: {
      storeId_userId: {
        storeId,
        userId,
      },
    },
  });

  if (!storeStaff || storeStaff.role !== 'OWNER') {
    throw new Error('Only store owners can delete stores');
  }

  // Get account for usage tracking
  const account = await subscriptionDal.getAccountByStoreId(storeId);

  // Delete store
  await prisma.store.delete({
    where: { id: storeId },
  });

  // RECORD STORE DELETION
  if (account) {
    await usageService.recordStoreDeletion(account.id);
  }

  return { success: true };
}

/**
 * List stores for user's account
 */
export async function listStoresForUser(userId: string) {
  const account = await subscriptionDal.getAccountByUserId(userId);

  if (!account) {
    return [];
  }

  return prisma.store.findMany({
    where: {
      accountId: account.id,
    },
    include: {
      staff: {
        where: {
          userId,
        },
        select: {
          role: true,
        },
      },
    },
    orderBy: {
      createdAt: 'desc',
    },
  });
}

/**
 * Get store with account info
 */
export async function getStoreWithAccount(storeId: string) {
  return prisma.store.findUnique({
    where: { id: storeId },
    include: {
      account: {
        include: {
          subscription: {
            include: {
              plan: true,
            },
          },
        },
      },
    },
  });
}


================================================================================
FILE: services/storestaff.service.ts
================================================================================

import * as storeStaffDal from '@/dal/storestuff.dal';
import * as subscriptionDal from '@/dal/subscription.dal';
import * as usageService from '@/services/usage.service';
import { requireStoreRole } from '@/lib/auth/requireStore';
import { StoreRole } from '@/app/generated/prisma';
import prisma from '@/lib/prisma';

export async function addStaffMember(
  currentUserId: string,
  storeId: string,
  input: {
    email: string;
    role: StoreRole;
  }
) {
  // Only OWNER can add staff
  await requireStoreRole(currentUserId, storeId, 'OWNER');

  // GET ACCOUNT FROM STORE
  const account = await subscriptionDal.getAccountByStoreId(storeId);
  if (!account) {
    throw new Error('Store does not belong to any account');
  }

  // ENFORCE STAFF LIMIT (account-wide)
  await usageService.checkStaffLimit(account.id);

  // Find user by email
  const user = await prisma.user.findUnique({
    where: { email: input.email },
  });

  if (!user) {
    throw new Error('User not found with this email');
  }

  // Check if already a member
  const existing = await storeStaffDal.getStoreStaff(storeId, user.id);
  if (existing) {
    throw new Error('User is already a member of this store');
  }

  // Validate role
  if (!['OWNER', 'MANAGER', 'SUPPORT'].includes(input.role)) {
    throw new Error('Invalid role');
  }

  const staff = await storeStaffDal.addStoreStaff(storeId, user.id, input.role);

  // RECORD STAFF ADDITION
  await usageService.recordStaffAddition(account.id);

  return staff;
}

export async function updateStaffRole(
  currentUserId: string,
  storeId: string,
  targetUserId: string,
  newRole: StoreRole
) {
  // Only OWNER can change roles
  await requireStoreRole(currentUserId, storeId, 'OWNER');

  // Cannot change own role
  if (currentUserId === targetUserId) {
    throw new Error('Cannot change your own role');
  }

  // Validate new role
  if (!['OWNER', 'MANAGER', 'SUPPORT'].includes(newRole)) {
    throw new Error('Invalid role');
  }

  // Check if target is last owner
  const isLast = await storeStaffDal.isLastOwner(storeId, targetUserId);
  if (isLast && newRole !== 'OWNER') {
    throw new Error('Cannot demote the last owner');
  }

  return storeStaffDal.updateStoreStaffRole(storeId, targetUserId, newRole);
}

export async function removeStaffMember(
  currentUserId: string,
  storeId: string,
  targetUserId: string
) {
  // Only OWNER can remove staff
  await requireStoreRole(currentUserId, storeId, 'OWNER');

  // Cannot remove self
  if (currentUserId === targetUserId) {
    throw new Error('Cannot remove yourself from the store');
  }

  // Check if target is last owner
  const isLast = await storeStaffDal.isLastOwner(storeId, targetUserId);
  if (isLast) {
    throw new Error('Cannot remove the last owner');
  }

  const result = await storeStaffDal.removeStoreStaff(storeId, targetUserId);

  // GET ACCOUNT FROM STORE
  const account = await subscriptionDal.getAccountByStoreId(storeId);
  if (account) {
    // RECORD STAFF REMOVAL
    await usageService.recordStaffRemoval(account.id);
  }

  return result;
}

export async function listStaff(
  currentUserId: string,
  storeId: string
) {
  // Any staff member can view other members
  await requireStoreRole(currentUserId, storeId, 'SUPPORT');

  return storeStaffDal.listStoreStaff(storeId);
}

export async function getMyStores(userId: string) {
  return storeStaffDal.getUserStores(userId);
}

export async function getStaffMember(
  currentUserId: string,
  storeId: string,
  targetUserId: string
) {
  // Any staff member can view other members
  await requireStoreRole(currentUserId, storeId, 'SUPPORT');

  return storeStaffDal.getStoreStaff(storeId, targetUserId);
}


================================================================================
FILE: services/subscription.service.ts
================================================================================

import * as subscriptionDal from '@/dal/subscription.dal';
import { PlanType, SubscriptionStatus } from '@/app/generated/prisma';
import crypto from 'crypto';

/**
 * Create account for user
 */
export async function createAccountForUser(userId: string, name: string) {
  // Check if user already has an account
  const existingAccount = await subscriptionDal.getAccountByUserId(userId);
  if (existingAccount) {
    throw new Error('User already has an account');
  }

  return subscriptionDal.createAccount(name, userId);
}

/**
 * Initialize subscription with FREE plan
 */
export async function initializeFreeSubscription(accountId: string) {
  const freePlan = await subscriptionDal.getPlanByType('FREE');

  if (!freePlan) {
    throw new Error('FREE plan not configured');
  }

  const startDate = new Date();

  return subscriptionDal.createSubscription(accountId, freePlan.id, startDate);
}

/**
 * Upgrade subscription
 */
export async function upgradeSubscription(
  userId: string,
  accountId: string,
  planType: PlanType,
  paymentProvider: 'STRIPE' | 'RAZORPAY'
) {
  // Verify user owns account
  const account = await subscriptionDal.getAccountById(accountId);
  if (!account) {
    throw new Error('Account not found');
  }

  const isOwner = account.users.some(
    u => u.userId === userId && u.role === 'OWNER'
  );
  if (!isOwner) {
    throw new Error('Only account owners can upgrade subscriptions');
  }

  const newPlan = await subscriptionDal.getPlanByType(planType);
  if (!newPlan) {
    throw new Error('Plan not found');
  }

  // Validate against current subscription
  const currentSub = account.subscription;
  if (currentSub && currentSub.plan.price >= newPlan.price) {
    throw new Error('Can only upgrade to higher tier plans');
  }

  // Create invoice
  const now = new Date();
  const periodEnd = new Date(now);
  periodEnd.setMonth(periodEnd.getMonth() + 1);

  const invoice = await subscriptionDal.createInvoice(
    accountId,
    newPlan.price,
    now,
    periodEnd
  );

  // In production, trigger payment flow here
  // For now, return invoice details for client-side payment

  return {
    invoice,
    plan: newPlan,
    amount: newPlan.price,
    currency: 'INR',
  };
}

/**
 * Complete subscription upgrade after payment
 */
export async function completeSubscriptionUpgrade(
  accountId: string,
  invoiceId: string,
  paymentId: string
) {
  // Mark invoice as paid
  await subscriptionDal.markInvoicePaid(invoiceId, paymentId);

  // Get invoice to find plan
  const invoice = await subscriptionDal.GetInvoiceById(invoiceId );

  if (!invoice) {
    throw new Error('Invoice not found');
  }

  // Create or update subscription
  const account = await subscriptionDal.getAccountById(accountId);
  if (!account) {
    throw new Error('Account not found');
  }

  if (account.subscription) {
    // Upgrade existing subscription
    // Find plan by price (in production, store planId in invoice)
    const plans = await subscriptionDal.listActivePlans();
    const newPlan = plans.find(p => p.price === invoice.amount);

    if (!newPlan) {
      throw new Error('Plan not found for invoice amount');
    }

    return subscriptionDal.changeSubscriptionPlan(accountId, newPlan.id);
  } else {
    // Create new subscription
    const plans = await subscriptionDal.listActivePlans();
    const newPlan = plans.find(p => p.price === invoice.amount);

    if (!newPlan) {
      throw new Error('Plan not found for invoice amount');
    }

    return subscriptionDal.createSubscription(
      accountId,
      newPlan.id,
      invoice.periodStart
    );
  }
}

/**
 * Process subscription renewals (CRON job)
 */
export async function processSubscriptionRenewals() {
  const tomorrow = new Date();
  tomorrow.setDate(tomorrow.getDate() + 1);

  const expiringSubscriptions = await subscriptionDal.getSubscriptionsExpiringBefore(
    tomorrow
  );

  const results = {
    renewed: 0,
    failed: 0,
    canceled: 0,
  };

  for (const subscription of expiringSubscriptions) {
    try {
      if (subscription.cancelAtPeriodEnd) {
        // Cancel subscription
        await subscriptionDal.updateSubscriptionStatus(
          subscription.accountId,
          'CANCELED'
        );
        results.canceled++;
        continue;
      }

      // Create renewal invoice
      const invoice = await subscriptionDal.createInvoice(
        subscription.accountId,
        subscription.plan.price,
        subscription.currentPeriodEnd,
        new Date(subscription.currentPeriodEnd.getTime() + 30 * 24 * 60 * 60 * 1000)
      );

      // In production, trigger payment via payment provider
      // For now, simulate successful payment
      const paymentId = `auto_renewal_${crypto.randomBytes(8).toString('hex')}`;

      // Simulate payment processing
      // In real system, use Stripe/Razorpay API

      await subscriptionDal.markInvoicePaid(invoice.id, paymentId);
      await subscriptionDal.renewSubscription(subscription.accountId);

      results.renewed++;
    } catch (error) {
      console.error(
        `Failed to renew subscription for account ${subscription.accountId}:`,
        error
      );

      // Mark as PAST_DUE (give grace period)
      await subscriptionDal.updateSubscriptionStatus(
        subscription.accountId,
        'PAST_DUE'
      );

      results.failed++;
    }
  }

  return results;
}

/**
 * Cancel subscription at period end
 */
export async function cancelSubscription(userId: string, accountId: string) {
  const account = await subscriptionDal.getAccountById(accountId);
  if (!account) {
    throw new Error('Account not found');
  }

  const isOwner = account.users.some(
    u => u.userId === userId && u.role === 'OWNER'
  );
  if (!isOwner) {
    throw new Error('Only account owners can cancel subscriptions');
  }

  return subscriptionDal.cancelSubscriptionAtPeriodEnd(accountId);
}

/**
 * Get subscription status for account
 */
export async function getSubscriptionStatus(accountId: string) {
  const subscription = await subscriptionDal.getSubscriptionByAccountId(accountId);

  if (!subscription) {
    return {
      hasSubscription: false,
      status: null,
      plan: null,
      currentPeriodEnd: null,
    };
  }

  return {
    hasSubscription: true,
    status: subscription.status,
    plan: subscription.plan,
    currentPeriodStart: subscription.currentPeriodStart,
    currentPeriodEnd: subscription.currentPeriodEnd,
    cancelAtPeriodEnd: subscription.cancelAtPeriodEnd,
  };
}

/**
 * List available plans
 */
export async function listPlans() {
  return subscriptionDal.listActivePlans();
}


================================================================================
FILE: services/usage.service.ts
================================================================================

import * as subscriptionDal from '@/dal/subscription.dal';
import { UsageLimitError, ConflictError } from '@/lib/errors';

/**
 * CRITICAL OPTIMIZATION: All usage checks now read from UsageCounter
 * instead of running expensive count() queries.
 * 
 * The counter is kept in sync by increment/decrement operations
 * when resources are created/deleted.
 */

/**
 * Check if account can create a store
 */
export async function checkStoreLimit(accountId: string): Promise<void> {
  const subscription = await subscriptionDal.getSubscriptionByAccountId(accountId);

  if (!subscription) {
    throw new ConflictError('No active subscription');
  }

  if (subscription.status !== 'ACTIVE') {
    throw new ConflictError(`Subscription is ${subscription.status}. Cannot create stores.`);
  }

  const plan = subscription.plan;

  // ENTERPRISE has unlimited stores (NULL check)
  if (plan.maxStores === null) {
    return;
  }

  // Read from UsageCounter instead of counting rows
  const usage = await subscriptionDal.getCurrentUsage(accountId);

  if (usage.storeCount >= plan.maxStores) {
    throw new UsageLimitError(
      `Store limit reached. Your ${plan.name} plan allows ${plan.maxStores} stores.`,
      plan.maxStores,
      usage.storeCount,
      'stores'
    );
  }
}

/**
 * Check if account can create a product
 */
export async function checkProductLimit(accountId: string): Promise<void> {
  const subscription = await subscriptionDal.getSubscriptionByAccountId(accountId);

  if (!subscription) {
    throw new ConflictError('No active subscription');
  }

  if (subscription.status !== 'ACTIVE') {
    throw new ConflictError(`Subscription is ${subscription.status}. Cannot create products.`);
  }

  const plan = subscription.plan;

  // ENTERPRISE has unlimited products
  if (plan.maxProducts === null) {
    return;
  }

  // Read from UsageCounter instead of counting rows
  const usage = await subscriptionDal.getCurrentUsage(accountId);

  if (usage.productCount >= plan.maxProducts) {
    throw new UsageLimitError(
      `Product limit reached. Your ${plan.name} plan allows ${plan.maxProducts} products across all stores.`,
      plan.maxProducts,
      usage.productCount,
      'products'
    );
  }
}

/**
 * Check if account can create an order
 */
export async function checkOrderLimit(accountId: string): Promise<void> {
  return 
}
/**
 * Check if account can add staff
 */
export async function checkStaffLimit(accountId: string): Promise<void> {
  const subscription = await subscriptionDal.getSubscriptionByAccountId(accountId);

  if (!subscription) {
    throw new ConflictError('No active subscription');
  }

  if (subscription.status !== 'ACTIVE') {
    throw new ConflictError(`Subscription is ${subscription.status}. Cannot add staff.`);
  }

  const plan = subscription.plan;

  // ENTERPRISE has unlimited staff
  if (plan.maxStaffMembers === null) {
    return;
  }

  // Read from UsageCounter
  const usage = await subscriptionDal.getCurrentUsage(accountId);

  if (usage.staffCount >= plan.maxStaffMembers) {
    throw new UsageLimitError(
      `Staff limit reached. Your ${plan.name} plan allows ${plan.maxStaffMembers} staff members across all stores.`,
      plan.maxStaffMembers,
      usage.staffCount,
      'staff'
    );
  }
}

/**
 * Check if account can make API request
 */
export async function checkAPIRequestLimit(accountId: string): Promise<void> {
  const subscription = await subscriptionDal.getSubscriptionByAccountId(accountId);

  if (!subscription) {
    throw new ConflictError('No active subscription');
  }

  if (subscription.status !== 'ACTIVE') {
    throw new ConflictError(`Subscription is ${subscription.status}. API access denied.`);
  }

  const plan = subscription.plan;

  // ENTERPRISE has unlimited API requests
  if (plan.maxAPIRequestsPerMonth === null) {
    return;
  }

  // Read from UsageCounter
  const usage = await subscriptionDal.getCurrentUsage(accountId);

  if (usage.apiRequestCount >= plan.maxAPIRequestsPerMonth) {
    throw new UsageLimitError(
      `Monthly API request limit reached. Your ${plan.name} plan allows ${plan.maxAPIRequestsPerMonth} API requests per month.`,
      plan.maxAPIRequestsPerMonth,
      usage.apiRequestCount,
      'api_requests'
    );
  }
}

/**
 * Record store creation
 * Atomically increments the counter
 */
export async function recordStoreCreation(accountId: string): Promise<void> {
  await subscriptionDal.incrementUsage(accountId, 'storeCount');
}

/**
 * Record store deletion
 * Atomically decrements the counter
 */
export async function recordStoreDeletion(accountId: string): Promise<void> {
  await subscriptionDal.decrementUsage(accountId, 'storeCount');
}

/**
 * Record product creation
 * Atomically increments the counter
 */
export async function recordProductCreation(accountId: string): Promise<void> {
  await subscriptionDal.incrementUsage(accountId, 'productCount');
}

/**
 * Record product deletion
 * Atomically decrements the counter
 */
export async function recordProductDeletion(accountId: string): Promise<void> {
  await subscriptionDal.decrementUsage(accountId, 'productCount');
}

/**
 * Record order creation
 * Atomically increments the counter
 */
export async function recordOrderCreation(accountId: string): Promise<void> {
  await subscriptionDal.incrementUsage(accountId, 'orderCount');
}

/**
 * Record staff addition
 * Atomically increments the counter
 */
export async function recordStaffAddition(accountId: string): Promise<void> {
  await subscriptionDal.incrementUsage(accountId, 'staffCount');
}

/**
 * Record staff removal
 * Atomically decrements the counter
 */
export async function recordStaffRemoval(accountId: string): Promise<void> {
  await subscriptionDal.decrementUsage(accountId, 'staffCount');
}

/**
 * Record API request
 * Atomically increments the counter
 */
export async function recordAPIRequest(accountId: string): Promise<void> {
  await subscriptionDal.incrementUsage(accountId, 'apiRequestCount');
}

/**
 * Get usage summary for account
 * Shows current usage against limits
 */
export async function getUsageSummary(accountId: string) {
  const subscription = await subscriptionDal.getSubscriptionByAccountId(accountId);

  if (!subscription) {
    throw new ConflictError('No active subscription');
  }

  const usage = await subscriptionDal.getCurrentUsage(accountId);
  const plan = subscription.plan;

  return {
    plan: {
      name: plan.name,
      type: plan.type,
    },
    period: {
      start: subscription.currentPeriodStart,
      end: subscription.currentPeriodEnd,
    },
    usage: {
      stores: {
        current: usage.storeCount,
        limit: plan.maxStores,
        percentage: plan.maxStores
          ? Math.round((usage.storeCount / plan.maxStores) * 100)
          : 0,
      },
      products: {
        current: usage.productCount,
        limit: plan.maxProducts,
        percentage: plan.maxProducts
          ? Math.round((usage.productCount / plan.maxProducts) * 100)
          : 0,
      },
      orders: {
        current: usage.orderCount,
        limit: plan.maxOrdersPerMonth,
        percentage: plan.maxOrdersPerMonth
          ? Math.round((usage.orderCount / plan.maxOrdersPerMonth) * 100)
          : 0,
      },
      staff: {
        current: usage.staffCount,
        limit: plan.maxStaffMembers,
        percentage: plan.maxStaffMembers
          ? Math.round((usage.staffCount / plan.maxStaffMembers) * 100)
          : 0,
      },
      apiRequests: {
        current: usage.apiRequestCount,
        limit: plan.maxAPIRequestsPerMonth,
        percentage: plan.maxAPIRequestsPerMonth
          ? Math.round((usage.apiRequestCount / plan.maxAPIRequestsPerMonth) * 100)
          : 0,
      },
    },
  };
}

/**
 * Synchronize usage counters with actual database counts
 * This should be run periodically (e.g., daily cron job) to ensure
 * counters remain accurate despite any edge cases
 */
export async function synchronizeUsageCounters(accountId: string): Promise<void> {
  const [
    actualStores,
    actualProducts,
    actualStaff,
  ] = await Promise.all([
    subscriptionDal.getTotalStoreCount(accountId),
    subscriptionDal.getTotalProductCount(accountId),
    subscriptionDal.getTotalStaffCount(accountId),
  ]);

  const usage = await subscriptionDal.getCurrentUsage(accountId);

  // Calculate deltas
  const storeDelta = actualStores - usage.storeCount;
  const productDelta = actualProducts - usage.productCount;
  const staffDelta = actualStaff - usage.staffCount;

  // Apply corrections if needed
  if (storeDelta !== 0) {
    await subscriptionDal.incrementUsage(accountId, 'storeCount', storeDelta);
  }
  if (productDelta !== 0) {
    await subscriptionDal.incrementUsage(accountId, 'productCount', productDelta);
  }
  if (staffDelta !== 0) {
    await subscriptionDal.incrementUsage(accountId, 'staffCount', staffDelta);
  }
}


================================================================================
FILE: services/varient.service.ts
================================================================================

import * as variantDal from '@/dal/varient.dal';
import { requireStoreRole } from '@/lib/auth/requireStore';

export async function createVariant(
  userId: string,
  storeId: string,
  productId: string,
  input: {
    sku: string;
    price: number;
    stock: number;
    isActive?: boolean;
  }
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'MANAGER');

  // Validation
  if (!input.sku || input.sku.trim().length === 0) {
    throw new Error('SKU is required');
  }

  if (input.price < 0) {
    throw new Error('Price must be non-negative');
  }

  if (input.stock < 0) {
    throw new Error('Stock must be non-negative');
  }

  if (!Number.isInteger(input.price)) {
    throw new Error('Price must be in smallest currency unit (e.g., paise)');
  }

  if (!Number.isInteger(input.stock)) {
    throw new Error('Stock must be a whole number');
  }

  return variantDal.createVariant(storeId, productId, input);
}

export async function updateVariant(
  userId: string,
  storeId: string,
  variantId: string,
  input: {
    sku?: string;
    price?: number;
    stock?: number;
    isActive?: boolean;
  }
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'MANAGER');

  // Validation
  if (input.sku !== undefined && input.sku.trim().length === 0) {
    throw new Error('SKU cannot be empty');
  }

  if (input.price !== undefined) {
    if (input.price < 0) {
      throw new Error('Price must be non-negative');
    }
    if (!Number.isInteger(input.price)) {
      throw new Error('Price must be in smallest currency unit');
    }
  }

  if (input.stock !== undefined) {
    if (input.stock < 0) {
      throw new Error('Stock must be non-negative');
    }
    if (!Number.isInteger(input.stock)) {
      throw new Error('Stock must be a whole number');
    }
  }

  return variantDal.updateVariant(storeId, variantId, input);
}

export async function deleteVariant(
  userId: string,
  storeId: string,
  variantId: string
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'MANAGER');

  return variantDal.deleteVariant(storeId, variantId);
}

/**
 * Atomic stock update with validation.
 * Used for reserving/releasing inventory.
 */
export async function updateStock(
  userId: string,
  storeId: string,
  variantId: string,
  delta: number
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'MANAGER');

  // Validation
  if (!Number.isInteger(delta)) {
    throw new Error('Stock delta must be a whole number');
  }

  if (delta === 0) {
    throw new Error('Stock delta cannot be zero');
  }

  return variantDal.updateStockAtomic(storeId, variantId, delta);
}

export async function getVariant(storeId: string, variantId: string) {
  // Read access - no permission check needed
  return variantDal.getVariantById(storeId, variantId);
}

export async function attachFacetsToVariant(
  userId: string,
  storeId: string,
  variantId: string,
  facetValueIds: string[]
) {
  // Permission check
  await requireStoreRole(userId, storeId, 'MANAGER');

  return variantDal.attachFacetValuesToVariant(storeId, variantId, facetValueIds);
}


================================================================================
FILE: app/api/api-Keys/[id]/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { resolveTenant } from '@/lib/tenant/resolveTenant';
import * as apiKeyService from '@/services/apiKey.service';

/**
 * DELETE /api/api-keys/[id]
 * Revoke an API key (OWNER only)
 */
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const tenant = await resolveTenant();

    // API keys cannot revoke other API keys
    if (tenant.apiKeyId) {
      return NextResponse.json(
        { error: 'API keys cannot revoke other API keys' },
        { status: 403 }
      );
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required' },
        { status: 403 }
      );
    }

    await apiKeyService.revokeKey(tenant.userId, tenant.storeId, params.id);

    return NextResponse.json({ success: true, revoked: true });
  } catch (error: any) {
    console.error('Revoke API key error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to revoke API key' },
      { status: error.message?.includes('denied') || error.message?.includes('Only') ? 403 : 400 }
    );
  }
}

/**
 * Example Response:
 * {
 *   "success": true,
 *   "revoked": true
 * }
 */


================================================================================
FILE: app/api/api-Keys/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { resolveTenant } from '@/lib/tenant/resolveTenant';
import * as apiKeyService from '@/services/apiKey.service';

/**
 * POST /api/api-keys
 * Generate a new API key (OWNER only)
 */
export async function POST(req: NextRequest) {
  try {
    const tenant = await resolveTenant();

    // API keys cannot create other API keys
    if (tenant.apiKeyId) {
      return NextResponse.json(
        { error: 'API keys cannot create other API keys' },
        { status: 403 }
      );
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required' },
        { status: 403 }
      );
    }

    const body = await req.json();

    const apiKey = await apiKeyService.generateKey(
      tenant.userId,
      tenant.storeId,
      {
        name: body.name,
        scopes: body.scopes,
      }
    );

    return NextResponse.json(apiKey, { status: 201 });
  } catch (error: any) {
    console.error('Create API key error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to create API key' },
      { status: error.message?.includes('denied') || error.message?.includes('Only') ? 403 : 400 }
    );
  }
}

/**
 * GET /api/api-keys
 * List all API keys for the store (OWNER only)
 */
export async function GET(req: NextRequest) {
  try {
    const tenant = await resolveTenant();

    // API keys cannot list other API keys
    if (tenant.apiKeyId) {
      return NextResponse.json(
        { error: 'API keys cannot list other API keys' },
        { status: 403 }
      );
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required' },
        { status: 403 }
      );
    }

    const apiKeys = await apiKeyService.listKeys(tenant.userId, tenant.storeId);

    return NextResponse.json({ apiKeys });
  } catch (error: any) {
    console.error('List API keys error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to list API keys' },
      { status: error.message?.includes('denied') || error.message?.includes('Only') ? 403 : 400 }
    );
  }
}

/**
 * Example Request (POST):
 * {
 *   "name": "Production API Key",
 *   "scopes": ["products:read", "products:write", "orders:read"]
 * }
 * 
 * Example Response (POST):
 * {
 *   "id": "apikey_abc123",
 *   "keyId": "a1b2c3d4e5f6...",
 *   "storeId": "store_123",
 *   "name": "Production API Key",
 *   "scopes": ["products:read", "products:write", "orders:read"],
 *   "revokedAt": null,
 *   "lastUsedAt": null,
 *   "createdAt": "2026-01-06T10:30:00Z",
 *   "fullKey": "sk_live_a1b2c3d4e5f6..._7g8h9i0j1k2l..."
 * }
 * 
 * IMPORTANT: The "fullKey" is only returned once during creation.
 * Store it securely - it cannot be retrieved again.
 * 
 * Example Response (GET):
 * {
 *   "apiKeys": [
 *     {
 *       "id": "apikey_abc123",
 *       "keyId": "a1b2c3d4e5f6...",
 *       "name": "Production API Key",
 *       "scopes": ["products:read", "products:write"],
 *       "revokedAt": null,
 *       "lastUsedAt": "2026-01-06T09:15:00Z",
 *       "createdAt": "2026-01-05T14:20:00Z"
 *     }
 *   ]
 * }
 */


================================================================================
FILE: app/api/auth/[...nextauth]/route.ts
================================================================================

import { handlers } from "@/lib/auth";

export const { GET, POST } = handlers;


================================================================================
FILE: app/api/category/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { resolveTenant } from '@/lib/tenant/resolveTenant';
import * as categoryDal from '@/dal/category.dal';
import { requireStoreRole } from '@/lib/auth/requireStore';
import { hasWriteScope } from '@/services/apiKey.service';

/**
 * POST /api/categories
 * Create a new category
 */
export async function POST(req: NextRequest) {
  try {
    const tenant = await resolveTenant();

    // If using API key, check scopes
    if (tenant.apiKeyId && tenant.scopes) {
      if (!hasWriteScope(tenant.scopes, 'categories')) {
        return NextResponse.json(
          { error: 'Missing required scope: categories:write' },
          { status: 403 }
        );
      }
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required for this operation' },
        { status: 403 }
      );
    }

    // Permission check
    await requireStoreRole(tenant.userId, tenant.storeId, 'MANAGER');

    const body = await req.json();

    // Validation
    if (!body.name || body.name.trim().length === 0) {
      return NextResponse.json(
        { error: 'Category name is required' },
        { status: 400 }
      );
    }

    if (!body.slug || body.slug.trim().length === 0) {
      return NextResponse.json(
        { error: 'Category slug is required' },
        { status: 400 }
      );
    }

    const category = await categoryDal.createCategory(tenant.storeId, {
      name: body.name,
      slug: body.slug,
      parentId: body.parentId,
    });

    return NextResponse.json(category, { status: 201 });
  } catch (error: any) {
    console.error('Create category error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to create category' },
      { status: error.message?.includes('denied') ? 403 : 400 }
    );
  }
}

/**
 * GET /api/categories
 * List all categories (with tree structure)
 */
export async function GET(req: NextRequest) {
  try {
    const tenant = await resolveTenant();

    // If using API key, check scopes
    if (tenant.apiKeyId && tenant.scopes) {
      const hasRead = tenant.scopes.includes('*') || tenant.scopes.includes('categories:read');
      if (!hasRead) {
        return NextResponse.json(
          { error: 'Missing required scope: categories:read' },
          { status: 403 }
        );
      }
    }

    const { searchParams } = new URL(req.url);
    const tree = searchParams.get('tree') === 'true';

    const categories = tree 
      ? await categoryDal.getCategoryTree(tenant.storeId)
      : await categoryDal.listCategories(tenant.storeId);

    return NextResponse.json({ categories });
  } catch (error: any) {
    console.error('List categories error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to list categories' },
      { status: 400 }
    );
  }
}

/**
 * Example Request (POST):
 * {
 *   "name": "Men's Clothing",
 *   "slug": "mens-clothing",
 *   "parentId": null
 * }
 * 
 * Example Response (POST):
 * {
 *   "id": "cat_abc123",
 *   "storeId": "store_123",
 *   "name": "Men's Clothing",
 *   "slug": "mens-clothing",
 *   "parentId": null,
 *   "createdAt": "2026-01-06T10:30:00Z",
 *   "parent": null,
 *   "children": []
 * }
 * 
 * Example Request (GET):
 * GET /api/categories?tree=true
 * 
 * Example Response (GET):
 * {
 *   "categories": [
 *     {
 *       "id": "cat_abc123",
 *       "name": "Men's Clothing",
 *       "slug": "mens-clothing",
 *       "children": [
 *         {
 *           "id": "cat_def456",
 *           "name": "Jackets",
 *           "slug": "jackets",
 *           "children": []
 *         }
 *       ]
 *     }
 *   ]
 * }
 */11


================================================================================
FILE: app/api/discounts/[id]/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { resolveTenant } from '@/lib/tenant/resolveTenant';
import * as discountService from '@/services/discount.service';
import { hasWriteScope } from '@/services/apiKey.service';

/**
 * GET /api/discounts/[id]
 * Get single discount
 */
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const tenant = await resolveTenant();

    if (tenant.apiKeyId && tenant.scopes) {
      const hasRead = tenant.scopes.includes('*') || tenant.scopes.includes('discounts:read');
      if (!hasRead) {
        return NextResponse.json(
          { error: 'Missing required scope: discounts:read' },
          { status: 403 }
        );
      }
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required' },
        { status: 403 }
      );
    }

    const discount = await discountService.getDiscount(
      tenant.userId,
      tenant.storeId,
      params.id
    );

    if (!discount) {
      return NextResponse.json(
        { error: 'Discount not found' },
        { status: 404 }
      );
    }

    return NextResponse.json(discount);
  } catch (error: any) {
    console.error('Get discount error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to get discount' },
      { status: error.message?.includes('denied') ? 403 : 400 }
    );
  }
}

/**
 * PATCH /api/discounts/[id]
 * Update discount
 */
export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const tenant = await resolveTenant();

    if (tenant.apiKeyId && tenant.scopes) {
      if (!hasWriteScope(tenant.scopes, 'discounts')) {
        return NextResponse.json(
          { error: 'Missing required scope: discounts:write' },
          { status: 403 }
        );
      }
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required' },
        { status: 403 }
      );
    }

    const body = await req.json();

    const discount = await discountService.updateDiscount(
      tenant.userId,
      tenant.storeId,
      params.id,
      {
        code: body.code,
        name: body.name,
        description: body.description,
        value: body.value,
        startsAt: body.startsAt,
        endsAt: body.endsAt,
        maxUsageCount: body.maxUsageCount,
        maxUsagePerUser: body.maxUsagePerUser,
        minOrderValue: body.minOrderValue,
        isStackable: body.isStackable,
        isActive: body.isActive,
        productIds: body.productIds,
        categoryIds: body.categoryIds,
      }
    );

    return NextResponse.json(discount);
  } catch (error: any) {
    console.error('Update discount error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to update discount' },
      { status: error.message?.includes('denied') ? 403 : 400 }
    );
  }
}

/**
 * DELETE /api/discounts/[id]
 * Delete discount
 */
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const tenant = await resolveTenant();

    if (tenant.apiKeyId && tenant.scopes) {
      if (!hasWriteScope(tenant.scopes, 'discounts')) {
        return NextResponse.json(
          { error: 'Missing required scope: discounts:write' },
          { status: 403 }
        );
      }
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required' },
        { status: 403 }
      );
    }

    await discountService.deleteDiscount(
      tenant.userId,
      tenant.storeId,
      params.id
    );

    return NextResponse.json({ success: true });
  } catch (error: any) {
    console.error('Delete discount error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to delete discount' },
      { status: error.message?.includes('denied') ? 403 : 400 }
    );
  }
}


================================================================================
FILE: app/api/discounts/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { resolveTenant } from '@/lib/tenant/resolveTenant';
import * as discountService from '@/services/discount.service';
import { hasWriteScope } from '@/services/apiKey.service';

/**
 * POST /api/discounts
 * Create a new discount
 */
export async function POST(req: NextRequest) {
  try {
    const tenant = await resolveTenant();

    // Check API key scopes
    if (tenant.apiKeyId && tenant.scopes) {
      if (!hasWriteScope(tenant.scopes, 'discounts')) {
        return NextResponse.json(
          { error: 'Missing required scope: discounts:write' },
          { status: 403 }
        );
      }
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required for this operation' },
        { status: 403 }
      );
    }

    const body = await req.json();

    const discount = await discountService.createDiscount(
      tenant.userId,
      tenant.storeId,
      {
        code: body.code,
        name: body.name,
        description: body.description,
        type: body.type,
        value: body.value,
        scope: body.scope,
        startsAt: body.startsAt,
        endsAt: body.endsAt,
        maxUsageCount: body.maxUsageCount,
        maxUsagePerUser: body.maxUsagePerUser,
        minOrderValue: body.minOrderValue,
        isStackable: body.isStackable,
        productIds: body.productIds,
        categoryIds: body.categoryIds,
      }
    );

    return NextResponse.json(discount, { status: 201 });
  } catch (error: any) {
    console.error('Create discount error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to create discount' },
      { status: error.message?.includes('denied') ? 403 : 400 }
    );
  }
}

/**
 * GET /api/discounts
 * List discounts
 */
export async function GET(req: NextRequest) {
  try {
    const tenant = await resolveTenant();

    // Check API key scopes
    if (tenant.apiKeyId && tenant.scopes) {
      const hasRead = tenant.scopes.includes('*') || tenant.scopes.includes('discounts:read');
      if (!hasRead) {
        return NextResponse.json(
          { error: 'Missing required scope: discounts:read' },
          { status: 403 }
        );
      }
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required for this operation' },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(req.url);

    const filters = {
      isActive: searchParams.get('isActive') === 'true' ? true :
                searchParams.get('isActive') === 'false' ? false : undefined,
      scope: searchParams.get('scope') as any,
      skip: parseInt(searchParams.get('skip') || '0'),
      take: parseInt(searchParams.get('take') || '50'),
    };

    const result = await discountService.listDiscounts(
      tenant.userId,
      tenant.storeId,
      filters
    );

    return NextResponse.json(result);
  } catch (error: any) {
    console.error('List discounts error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to list discounts' },
      { status: error.message?.includes('denied') ? 403 : 400 }
    );
  }
}

/**
 * Example Request (POST - Percentage Store-wide):
 * {
 *   "code": "SUMMER10",
 *   "name": "Summer Sale",
 *   "description": "10% off everything",
 *   "type": "PERCENTAGE",
 *   "value": 1000,
 *   "scope": "STORE_WIDE",
 *   "startsAt": "2026-06-01T00:00:00Z",
 *   "endsAt": "2026-08-31T23:59:59Z",
 *   "maxUsageCount": 1000,
 *   "maxUsagePerUser": 1,
 *   "minOrderValue": 100000,
 *   "isStackable": false
 * }
 * 
 * Example Request (POST - Fixed Amount Product-specific):
 * {
 *   "code": "JACKET200",
 *   "name": "200 off Jackets",
 *   "type": "FIXED_AMOUNT",
 *   "value": 20000,
 *   "scope": "PRODUCT",
 *   "startsAt": "2026-01-01T00:00:00Z",
 *   "endsAt": "2026-12-31T23:59:59Z",
 *   "productIds": ["prod_abc123", "prod_def456"],
 *   "isStackable": true
 * }
 */


================================================================================
FILE: app/api/facets/[id]/value/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { resolveTenant } from '@/lib/tenant/resolveTenant';
import * as facetDal from '@/dal/facet.dal';
import { requireStoreRole } from '@/lib/auth/requireStore';
import { hasWriteScope } from '@/services/apiKey.service';

/**
 * POST /api/facets/[id]/values
 * Add a new value to a facet
 */
export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const tenant = await resolveTenant();

    // If using API key, check scopes
    if (tenant.apiKeyId && tenant.scopes) {
      if (!hasWriteScope(tenant.scopes, 'products')) {
        return NextResponse.json(
          { error: 'Missing required scope: products:write' },
          { status: 403 }
        );
      }
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required for this operation' },
        { status: 403 }
      );
    }

    // Permission check
    await requireStoreRole(tenant.userId, tenant.storeId, 'MANAGER');

    const body = await req.json();

    // Validation
    if (!body.value || body.value.trim().length === 0) {
      return NextResponse.json(
        { error: 'Value is required' },
        { status: 400 }
      );
    }

    const facetValue = await facetDal.createFacetValue(
      tenant.storeId,
      params.id,
      body.value
    );

    return NextResponse.json(facetValue, { status: 201 });
  } catch (error: any) {
    console.error('Create facet value error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to create facet value' },
      { status: error.message?.includes('denied') ? 403 : 400 }
    );
  }
}

/**
 * Example Request:
 * {
 *   "value": "Navy Blue"
 * }
 * 
 * Example Response:
 * {
 *   "id": "fv_xyz789",
 *   "facetId": "facet_abc123",
 *   "value": "Navy Blue",
 *   "facet": {
 *     "id": "facet_abc123",
 *     "name": "Color",
 *     "code": "color"
 *   }
 * }
 */


================================================================================
FILE: app/api/facets/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { resolveTenant } from '@/lib/tenant/resolveTenant';
import * as facetDal from '@/dal/facet.dal';
import { requireStoreRole } from '@/lib/auth/requireStore';
import { hasWriteScope } from '@/services/apiKey.service';

/**
 * POST /api/facets
 * Create a new facet
 */
export async function POST(req: NextRequest) {
  try {
    const tenant = await resolveTenant();

    // If using API key, check scopes
    if (tenant.apiKeyId && tenant.scopes) {
      if (!hasWriteScope(tenant.scopes, 'products')) {
        return NextResponse.json(
          { error: 'Missing required scope: products:write' },
          { status: 403 }
        );
      }
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required for this operation' },
        { status: 403 }
      );
    }

    // Permission check
    await requireStoreRole(tenant.userId, tenant.storeId, 'MANAGER');

    const body = await req.json();

    // Validation
    if (!body.name || body.name.trim().length === 0) {
      return NextResponse.json(
        { error: 'Facet name is required' },
        { status: 400 }
      );
    }

    if (!body.code || body.code.trim().length === 0) {
      return NextResponse.json(
        { error: 'Facet code is required' },
        { status: 400 }
      );
    }

    const facet = await facetDal.createFacet(tenant.storeId, {
      name: body.name,
      code: body.code,
    });

    return NextResponse.json(facet, { status: 201 });
  } catch (error: any) {
    console.error('Create facet error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to create facet' },
      { status: error.message?.includes('denied') ? 403 : 400 }
    );
  }
}

/**
 * GET /api/facets
 * List all facets with their values
 */
export async function GET(req: NextRequest) {
  try {
    const tenant = await resolveTenant();

    // If using API key, check scopes
    if (tenant.apiKeyId && tenant.scopes) {
      const hasRead = tenant.scopes.includes('*') || tenant.scopes.includes('products:read');
      if (!hasRead) {
        return NextResponse.json(
          { error: 'Missing required scope: products:read' },
          { status: 403 }
        );
      }
    }

    const facets = await facetDal.listFacets(tenant.storeId);

    return NextResponse.json({ facets });
  } catch (error: any) {
    console.error('List facets error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to list facets' },
      { status: 400 }
    );
  }
}

/**
 * Example Request (POST):
 * {
 *   "name": "Color",
 *   "code": "color"
 * }
 * 
 * Example Response (POST):
 * {
 *   "id": "facet_abc123",
 *   "storeId": "store_123",
 *   "name": "Color",
 *   "code": "color",
 *   "createdAt": "2026-01-06T10:30:00Z",
 *   "values": []
 * }
 * 
 * Example Response (GET):
 * {
 *   "facets": [
 *     {
 *       "id": "facet_abc123",
 *       "name": "Color",
 *       "code": "color",
 *       "values": [
 *         { "id": "fv_123", "value": "Red" },
 *         { "id": "fv_124", "value": "Blue" }
 *       ]
 *     }
 *   ]
 * }
 */


================================================================================
FILE: app/api/orders/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { resolveTenant } from '@/lib/tenant/resolveTenant';
import * as orderService from '@/services/order.service';
import { hasWriteScope } from '@/services/apiKey.service';
import { OrderStatus } from '@/app/generated/prisma';
import { toErrorResponse } from '@/lib/errors';

/**
 * POST /api/orders
 * Create a new order with automatic discount calculation
 */
export async function POST(req: NextRequest) {
  try {
    const tenant = await resolveTenant();

    // Check API key scopes
    if (tenant.apiKeyId && tenant.scopes) {
      if (!hasWriteScope(tenant.scopes, 'orders')) {
        return NextResponse.json(
          { error: 'Missing required scope: orders:write' },
          { status: 403 }
        );
      }
    }

    const body = await req.json();

    // CRITICAL: Never trust client-provided totals
    // All calculations happen server-side in orderService

    const order = await orderService.createOrder(
      tenant.storeId, 
      {
        userId: body.userId || tenant.userId,
        lines: body.lines,
        currency: body.currency,
      },
      body.couponCode // Optional coupon code
    );

    return NextResponse.json(order, { status: 201 });
  } catch (error: any) {
    const errorResponse = toErrorResponse(error);
    return NextResponse.json(
      { error: errorResponse.error, details: errorResponse.details },
      { status: errorResponse.statusCode }
    );
  }
}

/**
 * GET /api/orders
 * List orders
 */
export async function GET(req: NextRequest) {
  try {
    const tenant = await resolveTenant();

    // Check API key scopes
    if (tenant.apiKeyId && tenant.scopes) {
      const hasRead = tenant.scopes.includes('*') || tenant.scopes.includes('orders:read');
      if (!hasRead) {
        return NextResponse.json(
          { error: 'Missing required scope: orders:read' },
          { status: 403 }
        );
      }
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required for this operation' },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(req.url);

    const filters = {
      userId: searchParams.get('userId') || undefined,
      status: searchParams.get('status') as OrderStatus | undefined,
      skip: parseInt(searchParams.get('skip') || '0'),
      take: parseInt(searchParams.get('take') || '50'),
    };

    const result = await orderService.listOrders(
      tenant.userId,
      tenant.storeId,
      filters
    );

    return NextResponse.json(result);
  } catch (error: any) {
    const errorResponse = toErrorResponse(error);
    return NextResponse.json(
      { error: errorResponse.error, details: errorResponse.details },
      { status: errorResponse.statusCode }
    );
  }
}

/**
 * Example Request (POST):
 * {
 *   "userId": "user_abc123",
 *   "lines": [
 *     {
 *       "variantId": "var_xyz789",
 *       "quantity": 2
 *     },
 *     {
 *       "variantId": "var_def456",
 *       "quantity": 1
 *     }
 *   ],
 *   "currency": "INR",
 *   "couponCode": "SUMMER10"
 * }
 * 
 * Example Response (POST - Success):
 * {
 *   "id": "order_abc123",
 *   "storeId": "store_123",
 *   "userId": "user_abc123",
 *   "subtotal": 44997,
 *   "discountAmount": 4500,
 *   "total": 40497,
 *   "currency": "INR",
 *   "status": "PENDING",
 *   "createdAt": "2026-01-06T10:30:00.000Z",
 *   "lines": [...],
 *   "discounts": [
 *     {
 *       "discountId": "disc_xyz",
 *       "amount": 4500,
 *       "discount": {
 *         "id": "disc_xyz",
 *         "code": "SUMMER10",
 *         "name": "Summer Sale",
 *         "type": "PERCENTAGE",
 *         "value": 1000
 *       }
 *     }
 *   ],
 *   "payments": []
 * }
 * 
 * Example Response (POST - Validation Error):
 * {
 *   "error": "Quantity must be positive",
 *   "details": {
 *     "field": "quantity"
 *   }
 * }
 * 
 * Example Response (POST - Usage Limit):
 * {
 *   "error": "Monthly order limit reached. Your Basic plan allows 100 orders per month.",
 *   "details": {
 *     "limit": 100,
 *     "current": 100,
 *     "resource": "orders"
 *   }
 * }
 * 
 * Example Response (POST - Insufficient Stock):
 * {
 *   "error": "Insufficient stock for JACKET-BLK-L. Available: 5, Requested: 10"
 * }
 */


================================================================================
FILE: app/api/paymentConfigs/[id]/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { resolveTenant } from '@/lib/tenant/resolveTenant';
import * as paymentConfigService from '@/services/paymentConfig.service';

/**
 * GET /api/payment-configs/[id]
 * Get single payment configuration
 */
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const tenant = await resolveTenant();

    if (tenant.apiKeyId) {
      return NextResponse.json(
        { error: 'Payment configurations cannot be accessed via API keys' },
        { status: 403 }
      );
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required' },
        { status: 403 }
      );
    }

    const config = await paymentConfigService.getPaymentConfig(
      tenant.userId,
      tenant.storeId,
      params.id
    );

    if (!config) {
      return NextResponse.json(
        { error: 'Payment configuration not found' },
        { status: 404 }
      );
    }

    return NextResponse.json(config);
  } catch (error: any) {
    console.error('Get payment config error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to get payment configuration' },
      { status: error.message?.includes('Only') ? 403 : 400 }
    );
  }
}

/**
 * PATCH /api/payment-configs/[id]
 * Update payment configuration
 */
export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const tenant = await resolveTenant();

    if (tenant.apiKeyId) {
      return NextResponse.json(
        { error: 'Payment configurations cannot be managed via API keys' },
        { status: 403 }
      );
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required' },
        { status: 403 }
      );
    }

    const body = await req.json();

    const config = await paymentConfigService.updatePaymentConfig(
      tenant.userId,
      tenant.storeId,
      params.id,
      {
        apiKey: body.apiKey,
        apiSecret: body.apiSecret,
        webhookSecret: body.webhookSecret,
        isLive: body.isLive,
        isActive: body.isActive,
      }
    );

    return NextResponse.json(config);
  } catch (error: any) {
    console.error('Update payment config error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to update payment configuration' },
      { status: error.message?.includes('Only') ? 403 : 400 }
    );
  }
}

/**
 * DELETE /api/payment-configs/[id]
 * Delete payment configuration
 */
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const tenant = await resolveTenant();

    if (tenant.apiKeyId) {
      return NextResponse.json(
        { error: 'Payment configurations cannot be managed via API keys' },
        { status: 403 }
      );
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required' },
        { status: 403 }
      );
    }

    await paymentConfigService.deletePaymentConfig(
      tenant.userId,
      tenant.storeId,
      params.id
    );

    return NextResponse.json({ success: true });
  } catch (error: any) {
    console.error('Delete payment config error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to delete payment configuration' },
      { status: error.message?.includes('Only') ? 403 : 400 }
    );
  }
}

/**
 * Example Request (PATCH):
 * {
 *   "apiKey": "sk_live_new_key...",
 *   "webhookSecret": "whsec_new_secret...",
 *   "isActive": false
 * }
 * 
 * Example Response (PATCH):
 * {
 *   "id": "pc_abc123",
 *   "storeId": "store_123",
 *   "provider": "STRIPE",
 *   "isLive": true,
 *   "isActive": false,
 *   "createdAt": "2026-01-06T10:30:00.000Z",
 *   "updatedAt": "2026-01-06T11:45:00.000Z"
 * }
 * 
 * Example Response (DELETE):
 * {
 *   "success": true
 * }
 */


================================================================================
FILE: app/api/paymentConfigs/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { resolveTenant } from '@/lib/tenant/resolveTenant';
import * as paymentConfigService from '@/services/paymentConfig.service';

/**
 * POST /api/payment-configs
 * Create payment provider configuration
 */
export async function POST(req: NextRequest) {
  try {
    const tenant = await resolveTenant();

    // Payment configs can only be managed via session (not API keys)
    if (tenant.apiKeyId) {
      return NextResponse.json(
        { error: 'Payment configurations cannot be managed via API keys' },
        { status: 403 }
      );
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required' },
        { status: 403 }
      );
    }

    const body = await req.json();

    const config = await paymentConfigService.createPaymentConfig(
      tenant.userId,
      tenant.storeId,
      {
        provider: body.provider,
        apiKey: body.apiKey,
        apiSecret: body.apiSecret,
        webhookSecret: body.webhookSecret,
        isLive: body.isLive ?? false,
      }
    );

    return NextResponse.json(config, { status: 201 });
  } catch (error: any) {
    console.error('Create payment config error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to create payment configuration' },
      { status: error.message?.includes('Only') ? 403 : 400 }
    );
  }
}

/**
 * GET /api/payment-configs
 * List all payment configurations for store
 */
export async function GET(req: NextRequest) {
  try {
    const tenant = await resolveTenant();

    // Payment configs can only be viewed via session
    if (tenant.apiKeyId) {
      return NextResponse.json(
        { error: 'Payment configurations cannot be accessed via API keys' },
        { status: 403 }
      );
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required' },
        { status: 403 }
      );
    }

    const configs = await paymentConfigService.listPaymentConfigs(
      tenant.userId,
      tenant.storeId
    );

    return NextResponse.json({ configs });
  } catch (error: any) {
    console.error('List payment configs error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to list payment configurations' },
      { status: error.message?.includes('Only') ? 403 : 400 }
    );
  }
}

/**
 * Example Request (POST - Stripe):
 * {
 *   "provider": "STRIPE",
 *   "apiKey": "sk_live_51A...",
 *   "webhookSecret": "whsec_...",
 *   "isLive": true
 * }
 * 
 * Example Request (POST - Razorpay):
 * {
 *   "provider": "RAZORPAY",
 *   "apiKey": "rzp_live_...",
 *   "apiSecret": "...",
 *   "isLive": true
 * }
 * 
 * Example Request (POST - Manual):
 * {
 *   "provider": "MANUAL",
 *   "apiKey": "manual-payment-tracking-id",
 *   "isLive": true
 * }
 * 
 * Example Response (POST):
 * {
 *   "id": "pc_abc123",
 *   "storeId": "store_123",
 *   "provider": "STRIPE",
 *   "isLive": true,
 *   "isActive": true,
 *   "createdAt": "2026-01-06T10:30:00.000Z",
 *   "updatedAt": "2026-01-06T10:30:00.000Z"
 * }
 * 
 * Example Response (GET):
 * {
 *   "configs": [
 *     {
 *       "id": "pc_abc123",
 *       "provider": "STRIPE",
 *       "isLive": true,
 *       "isActive": true,
 *       "createdAt": "2026-01-06T10:30:00.000Z",
 *       "updatedAt": "2026-01-06T10:30:00.000Z"
 *     },
 *     {
 *       "id": "pc_def456",
 *       "provider": "RAZORPAY",
 *       "isLive": false,
 *       "isActive": true,
 *       "createdAt": "2026-01-05T14:20:00.000Z",
 *       "updatedAt": "2026-01-05T14:20:00.000Z"
 *     }
 *   ]
 * }
 */


================================================================================
FILE: app/api/payments/intent/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { resolveTenant } from '@/lib/tenant/resolveTenant';
import * as orderDal from '@/dal/order.dal';
import { createStripePaymentIntent } from '@/lib/payments/stripe';
import { createRazorpayOrder } from '@/lib/payments/razorpay';

/**
 * POST /api/payments/intent
 * Create a payment intent for an order
 */
export async function POST(req: NextRequest) {
  try {
    const tenant = await resolveTenant();
    const body = await req.json();

    if (!body.orderId) {
      return NextResponse.json(
        { error: 'orderId is required' },
        { status: 400 }
      );
    }

    if (!body.provider) {
      return NextResponse.json(
        { error: 'provider is required (STRIPE, RAZORPAY, or MANUAL)' },
        { status: 400 }
      );
    }

    // Get order details
    const order = await orderDal.getOrderById(tenant.storeId, body.orderId);

    if (!order) {
      return NextResponse.json(
        { error: 'Order not found' },
        { status: 404 }
      );
    }

    if (order.status === 'PAID') {
      return NextResponse.json(
        { error: 'Order is already paid' },
        { status: 400 }
      );
    }

    if (order.status === 'CANCELLED') {
      return NextResponse.json(
        { error: 'Order is cancelled' },
        { status: 400 }
      );
    }

    const provider = body.provider.toUpperCase();
    const currency = body.currency || 'INR';

    switch (provider) {
      case 'STRIPE': {
        const result = await createStripePaymentIntent(
          tenant.storeId,
          body.orderId,
          order.total,
          currency.toLowerCase()
        );
        return NextResponse.json({
          provider: 'STRIPE',
          ...result,
        });
      }

      case 'RAZORPAY': {
        const result = await createRazorpayOrder(
          tenant.storeId,
          body.orderId,
          order.total,
          currency.toUpperCase()
        );
        return NextResponse.json({
          provider: 'RAZORPAY',
          ...result,
        });
      }

      case 'MANUAL': {
        // Manual payments don't need payment intents
        return NextResponse.json({
          provider: 'MANUAL',
          message: 'Manual payment selected. Complete payment offline and update status.',
          orderId: body.orderId,
          amount: order.total,
        });
      }

      default:
        return NextResponse.json(
          { error: 'Unsupported payment provider' },
          { status: 400 }
        );
    }
  } catch (error: any) {
    console.error('Create payment intent error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to create payment intent' },
      { status: 400 }
    );
  }
}

/**
 * Example Request (Stripe):
 * {
 *   "orderId": "order_abc123",
 *   "provider": "STRIPE",
 *   "currency": "INR"
 * }
 * 
 * Example Response (Stripe):
 * {
 *   "provider": "STRIPE",
 *   "paymentId": "pay_xyz789",
 *   "clientSecret": "pi_xxx_secret_yyy",
 *   "paymentIntentId": "pi_xxx"
 * }
 * 
 * Example Request (Razorpay):
 * {
 *   "orderId": "order_abc123",
 *   "provider": "RAZORPAY",
 *   "currency": "INR"
 * }
 * 
 * Example Response (Razorpay):
 * {
 *   "provider": "RAZORPAY",
 *   "paymentId": "pay_xyz789",
 *   "razorpayOrderId": "order_xxx",
 *   "amount": 14999,
 *   "currency": "INR"
 * }
 * 
 * Client-side Integration:
 * 
 * // Stripe
 * const stripe = await loadStripe('pk_test_...');
 * const { error } = await stripe.confirmPayment({
 *   clientSecret,
 *   confirmParams: {
 *     return_url: 'https://your-app.com/order/success',
 *   },
 * });
 * 
 * // Razorpay
 * const options = {
 *   key: 'rzp_test_...',
 *   amount: response.amount,
 *   currency: response.currency,
 *   order_id: response.razorpayOrderId,
 *   handler: function (response) {
 *     // Send to /api/payments/verify
 *   },
 * };
 * const rzp = new Razorpay(options);
 * rzp.open();
 */


================================================================================
FILE: app/api/payments/verify/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { resolveTenant } from '@/lib/tenant/resolveTenant';
import { confirmStripePayment } from '@/lib/payments/stripe';
import { captureRazorpayPayment } from '@/lib/payments/razorpay';

/**
 * POST /api/payments/verify
 * Verify and capture payment
 */
export async function POST(req: NextRequest) {
  try {
    const tenant = await resolveTenant();
    const body = await req.json();

    if (!body.provider) {
      return NextResponse.json(
        { error: 'provider is required' },
        { status: 400 }
      );
    }

    const provider = body.provider.toUpperCase();

    switch (provider) {
      case 'STRIPE': {
        if (!body.paymentIntentId) {
          return NextResponse.json(
            { error: 'paymentIntentId is required for Stripe' },
            { status: 400 }
          );
        }

        const result = await confirmStripePayment(
          tenant.storeId,
          body.paymentIntentId
        );

        return NextResponse.json(result);
      }

      case 'RAZORPAY': {
        if (!body.orderId || !body.razorpayPaymentId || !body.razorpayOrderId || !body.razorpaySignature) {
          return NextResponse.json(
            { error: 'orderId, razorpayPaymentId, razorpayOrderId, and razorpaySignature are required for Razorpay' },
            { status: 400 }
          );
        }

        const result = await captureRazorpayPayment(
          tenant.storeId,
          body.orderId,
          body.razorpayPaymentId,
          body.razorpayOrderId,
          body.razorpaySignature
        );

        return NextResponse.json(result);
      }

      default:
        return NextResponse.json(
          { error: 'Unsupported payment provider' },
          { status: 400 }
        );
    }
  } catch (error: any) {
    console.error('Verify payment error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to verify payment' },
      { status: 400 }
    );
  }
}

/**
 * Example Request (Stripe):
 * {
 *   "provider": "STRIPE",
 *   "paymentIntentId": "pi_xxx"
 * }
 * 
 * Example Response (Stripe):
 * {
 *   "success": true,
 *   "status": "succeeded"
 * }
 * 
 * Example Request (Razorpay):
 * {
 *   "provider": "RAZORPAY",
 *   "orderId": "order_abc123",
 *   "razorpayPaymentId": "pay_xxx",
 *   "razorpayOrderId": "order_xxx",
 *   "razorpaySignature": "abc123..."
 * }
 * 
 * Example Response (Razorpay):
 * {
 *   "success": true,
 *   "status": "captured"
 * }
 */


================================================================================
FILE: app/api/products/[id]/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { resolveTenant } from '@/lib/tenant/resolveTenant';
import * as productService from '@/services/product.service';
import { hasWriteScope } from '@/services/apiKey.service';

/**
 * GET /api/products/[id]
 * Get single product by ID
 */
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const tenant = await resolveTenant();

    // If using API key, check scopes
    if (tenant.apiKeyId && tenant.scopes) {
      const hasRead = tenant.scopes.includes('*') || tenant.scopes.includes('products:read');
      if (!hasRead) {
        return NextResponse.json(
          { error: 'Missing required scope: products:read' },
          { status: 403 }
        );
      }
    }

    const product = await productService.getProduct(tenant.storeId, params.id);

    if (!product) {
      return NextResponse.json(
        { error: 'Product not found' },
        { status: 404 }
      );
    }

    return NextResponse.json(product);
  } catch (error: any) {
    console.error('Get product error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to get product' },
      { status: 400 }
    );
  }
}

/**
 * PATCH /api/products/[id]
 * Update product
 */
export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const tenant = await resolveTenant();

    // If using API key, check scopes
    if (tenant.apiKeyId && tenant.scopes) {
      if (!hasWriteScope(tenant.scopes, 'products')) {
        return NextResponse.json(
          { error: 'Missing required scope: products:write' },
          { status: 403 }
        );
      }
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required for this operation' },
        { status: 403 }
      );
    }

    const body = await req.json();

    const product = await productService.updateProduct(
      tenant.userId,
      tenant.storeId,
      params.id,
      {
        name: body.name,
        description: body.description,
        categoryId: body.categoryId,
        isActive: body.isActive,
      }
    );

    return NextResponse.json(product);
  } catch (error: any) {
    console.error('Update product error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to update product' },
      { status: error.message?.includes('denied') ? 403 : 400 }
    );
  }
}

/**
 * DELETE /api/products/[id]
 * Delete product
 */
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const tenant = await resolveTenant();

    // If using API key, check scopes
    if (tenant.apiKeyId && tenant.scopes) {
      if (!hasWriteScope(tenant.scopes, 'products')) {
        return NextResponse.json(
          { error: 'Missing required scope: products:write' },
          { status: 403 }
        );
      }
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required for this operation' },
        { status: 403 }
      );
    }

    await productService.deleteProduct(tenant.userId, tenant.storeId, params.id);

    return NextResponse.json({ success: true }, { status: 200 });
  } catch (error: any) {
    console.error('Delete product error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to delete product' },
      { status: error.message?.includes('denied') ? 403 : 400 }
    );
  }
}

/**
 * Example Request (PATCH):
 * {
 *   "name": "Updated Product Name",
 *   "isActive": false
 * }
 * 
 * Example Response (PATCH):
 * {
 *   "id": "prod_xyz789",
 *   "name": "Updated Product Name",
 *   "isActive": false,
 *   ...
 * }
 */


================================================================================
FILE: app/api/products/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { resolveTenant } from '@/lib/tenant/resolveTenant';
import * as productService from '@/services/product.service';
import { hasWriteScope } from '@/services/apiKey.service';

/**
 * POST /api/products
 * Create a new product
 */
export async function POST(req: NextRequest) {
  try {
    const tenant = await resolveTenant();

    // If using API key, check scopes
    if (tenant.apiKeyId && tenant.scopes) {
      if (!hasWriteScope(tenant.scopes, 'products')) {
        return NextResponse.json(
          { error: 'Missing required scope: products:write' },
          { status: 403 }
        );
      }
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required for this operation' },
        { status: 403 }
      );
    }

    const body = await req.json();

    const product = await productService.createProduct(
      tenant.userId,
      tenant.storeId,
      {
        name: body.name,
        description: body.description,
        categoryId: body.categoryId,
        isActive: body.isActive,
      }
    );

    return NextResponse.json(product, { status: 201 });
  } catch (error: any) {
    console.error('Create product error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to create product' },
      { status: error.message?.includes('denied') ? 403 : 400 }
    );
  }
}

/**
 * GET /api/products
 * List products with filters
 */
export async function GET(req: NextRequest) {
  try {
    const tenant = await resolveTenant();

    // If using API key, check scopes
    if (tenant.apiKeyId && tenant.scopes) {
      const hasRead = tenant.scopes.includes('*') || tenant.scopes.includes('products:read');
      if (!hasRead) {
        return NextResponse.json(
          { error: 'Missing required scope: products:read' },
          { status: 403 }
        );
      }
    }

    const { searchParams } = new URL(req.url);
    
    const filters = {
      categoryId: searchParams.get('categoryId') || undefined,
      isActive: searchParams.get('isActive') === 'true' ? true : 
                searchParams.get('isActive') === 'false' ? false : undefined,
      search: searchParams.get('search') || undefined,
      skip: parseInt(searchParams.get('skip') || '0'),
      take: parseInt(searchParams.get('take') || '50'),
    };

    const result = await productService.listProducts(tenant.storeId, filters);

    return NextResponse.json(result);
  } catch (error: any) {
    console.error('List products error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to list products' },
      { status: 400 }
    );
  }
}

/**
 * Example Request (POST):
 * {
 *   "name": "Premium Leather Jacket",
 *   "description": "High-quality leather jacket",
 *   "categoryId": "cat_abc123",
 *   "isActive": true
 * }
 * 
 * Example Response (POST):
 * {
 *   "id": "prod_xyz789",
 *   "storeId": "store_123",
 *   "name": "Premium Leather Jacket",
 *   "description": "High-quality leather jacket",
 *   "categoryId": "cat_abc123",
 *   "isActive": true,
 *   "createdAt": "2026-01-06T10:30:00Z",
 *   "category": {...},
 *   "variants": [],
 *   "images": []
 * }
 * 
 * Example Request (GET):
 * GET /api/products?categoryId=cat_abc123&isActive=true&skip=0&take=20
 * 
 * Example Response (GET):
 * {
 *   "products": [{...}, {...}],
 *   "total": 45
 * }
 */


================================================================================
FILE: app/api/store-staff/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { resolveTenant } from '@/lib/tenant/resolveTenant';
import * as storeStaffService from '@/services/storestaff.service';

/**
 * POST /api/store-staff
 * Add a staff member to the store (OWNER only)
 */
export async function POST(req: NextRequest) {
  try {
    const tenant = await resolveTenant();

    // Staff management requires session (not API keys)
    if (tenant.apiKeyId) {
      return NextResponse.json(
        { error: 'Staff management cannot be done via API keys' },
        { status: 403 }
      );
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required' },
        { status: 403 }
      );
    }

    const body = await req.json();

    if (!body.email) {
      return NextResponse.json(
        { error: 'Email is required' },
        { status: 400 }
      );
    }

    if (!body.role) {
      return NextResponse.json(
        { error: 'Role is required' },
        { status: 400 }
      );
    }

    const staff = await storeStaffService.addStaffMember(
      tenant.userId,
      tenant.storeId,
      {
        email: body.email,
        role: body.role,
      }
    );

    return NextResponse.json(staff, { status: 201 });
  } catch (error: any) {
    console.error('Add staff error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to add staff member' },
      { status: error.message?.includes('Only') || error.message?.includes('already') ? 403 : 400 }
    );
  }
}

/**
 * GET /api/store-staff
 * List all staff members (requires SUPPORT role)
 */
export async function GET(req: NextRequest) {
  try {
    const tenant = await resolveTenant();

    if (tenant.apiKeyId) {
      return NextResponse.json(
        { error: 'Staff management cannot be accessed via API keys' },
        { status: 403 }
      );
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required' },
        { status: 403 }
      );
    }

    const staff = await storeStaffService.listStaff(
      tenant.userId,
      tenant.storeId
    );

    return NextResponse.json({ staff });
  } catch (error: any) {
    console.error('List staff error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to list staff' },
      { status: error.message?.includes('denied') ? 403 : 400 }
    );
  }
}

/**
 * Example Request (POST):
 * {
 *   "email": "john@example.com",
 *   "role": "MANAGER"
 * }
 * 
 * Example Response (POST):
 * {
 *   "id": "staff_abc123",
 *   "storeId": "store_123",
 *   "userId": "user_xyz789",
 *   "role": "MANAGER",
 *   "createdAt": "2026-01-06T10:30:00.000Z",
 *   "user": {
 *     "id": "user_xyz789",
 *     "email": "john@example.com",
 *     "name": "John Doe",
 *     "image": null
 *   }
 * }
 * 
 * Example Response (GET):
 * {
 *   "staff": [
 *     {
 *       "id": "staff_abc123",
 *       "role": "OWNER",
 *       "user": {
 *         "id": "user_123",
 *         "email": "owner@example.com",
 *         "name": "Store Owner"
 *       }
 *     },
 *     {
 *       "id": "staff_def456",
 *       "role": "MANAGER",
 *       "user": {
 *         "id": "user_456",
 *         "email": "manager@example.com",
 *         "name": "John Manager"
 *       }
 *     }
 *   ]
 * }
 */


================================================================================
FILE: app/api/store-staff/[store-staff]/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { resolveTenant } from '@/lib/tenant/resolveTenant';
import * as storeStaffService from '@/services/storestaff.service';

/**
 * PATCH /api/store-staff/[userId]
 * Update staff member's role (OWNER only)
 */
export async function PATCH(
  req: NextRequest,
  { params }: { params: { userId: string } }
) {
  try {
    const tenant = await resolveTenant();

    if (tenant.apiKeyId) {
      return NextResponse.json(
        { error: 'Staff management cannot be done via API keys' },
        { status: 403 }
      );
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required' },
        { status: 403 }
      );
    }

    const body = await req.json();

    if (!body.role) {
      return NextResponse.json(
        { error: 'Role is required' },
        { status: 400 }
      );
    }

    const staff = await storeStaffService.updateStaffRole(
      tenant.userId,
      tenant.storeId,
      params.userId,
      body.role
    );

    return NextResponse.json(staff);
  } catch (error: any) {
    console.error('Update staff role error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to update staff role' },
      { status: error.message?.includes('Only') || error.message?.includes('Cannot') ? 403 : 400 }
    );
  }
}

/**
 * DELETE /api/store-staff/[userId]
 * Remove staff member from store (OWNER only)
 */
export async function DELETE(
  req: NextRequest,
  { params }: { params: { userId: string } }
) {
  try {
    const tenant = await resolveTenant();

    if (tenant.apiKeyId) {
      return NextResponse.json(
        { error: 'Staff management cannot be done via API keys' },
        { status: 403 }
      );
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required' },
        { status: 403 }
      );
    }

    await storeStaffService.removeStaffMember(
      tenant.userId,
      tenant.storeId,
      params.userId
    );

    return NextResponse.json({ success: true });
  } catch (error: any) {
    console.error('Remove staff error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to remove staff member' },
      { status: error.message?.includes('Only') || error.message?.includes('Cannot') ? 403 : 400 }
    );
  }
}

/**
 * Example Request (PATCH):
 * {
 *   "role": "SUPPORT"
 * }
 * 
 * Example Response (PATCH):
 * {
 *   "id": "staff_abc123",
 *   "storeId": "store_123",
 *   "userId": "user_xyz789",
 *   "role": "SUPPORT",
 *   "createdAt": "2026-01-06T10:30:00.000Z",
 *   "user": {
 *     "id": "user_xyz789",
 *     "email": "john@example.com",
 *     "name": "John Doe"
 *   }
 * }
 * 
 * Example Response (DELETE):
 * {
 *   "success": true
 * }
 */


================================================================================
FILE: app/api/varients/[id]/stock/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { resolveTenant } from '@/lib/tenant/resolveTenant';
import * as variantService from '@/services/varient.service';
import { hasWriteScope } from '@/services/apiKey.service';

/**
 * PATCH /api/variants/[id]/stock
 * Atomically update variant stock
 */
export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const tenant = await resolveTenant();

    // If using API key, check scopes
    if (tenant.apiKeyId && tenant.scopes) {
      if (!hasWriteScope(tenant.scopes, 'products')) {
        return NextResponse.json(
          { error: 'Missing required scope: products:write' },
          { status: 403 }
        );
      }
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required for this operation' },
        { status: 403 }
      );
    }

    const body = await req.json();

    if (body.delta === undefined) {
      return NextResponse.json(
        { error: 'delta is required' },
        { status: 400 }
      );
    }

    const variant = await variantService.updateStock(
      tenant.userId,
      tenant.storeId,
      params.id,
      body.delta
    );

    return NextResponse.json(variant);
  } catch (error: any) {
    console.error('Update stock error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to update stock' },
      { status: error.message?.includes('denied') || error.message?.includes('Insufficient') ? 403 : 400 }
    );
  }
}

/**
 * Example Request (Increase stock):
 * {
 *   "delta": 20
 * }
 * 
 * Example Request (Decrease stock):
 * {
 *   "delta": -5
 * }
 * 
 * Example Response:
 * {
 *   "id": "var_abc123",
 *   "sku": "JACKET-BLK-L",
 *   "price": 14999,
 *   "stock": 65,
 *   "isActive": true
 * }
 */


================================================================================
FILE: app/api/varients/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { resolveTenant } from '@/lib/tenant/resolveTenant';
import * as variantService from '@/services/varient.service';
import { hasWriteScope } from '@/services/apiKey.service';

/**
 * POST /api/variants
 * Create a new variant
 */
export async function POST(req: NextRequest) {
  try {
    const tenant = await resolveTenant();

    // If using API key, check scopes
    if (tenant.apiKeyId && tenant.scopes) {
      if (!hasWriteScope(tenant.scopes, 'products')) {
        return NextResponse.json(
          { error: 'Missing required scope: products:write' },
          { status: 403 }
        );
      }
    }

    if (!tenant.userId) {
      return NextResponse.json(
        { error: 'User authentication required for this operation' },
        { status: 403 }
      );
    }

    const body = await req.json();

    if (!body.productId) {
      return NextResponse.json(
        { error: 'productId is required' },
        { status: 400 }
      );
    }

    const variant = await variantService.createVariant(
      tenant.userId,
      tenant.storeId,
      body.productId,
      {
        sku: body.sku,
        price: body.price,
        stock: body.stock,
        isActive: body.isActive,
      }
    );

    return NextResponse.json(variant, { status: 201 });
  } catch (error: any) {
    console.error('Create variant error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to create variant' },
      { status: error.message?.includes('denied') ? 403 : 400 }
    );
  }
}

/**
 * Example Request:
 * {
 *   "productId": "prod_xyz789",
 *   "sku": "JACKET-BLK-L",
 *   "price": 14999,
 *   "stock": 50,
 *   "isActive": true
 * }
 * 
 * Example Response:
 * {
 *   "id": "var_abc123",
 *   "productId": "prod_xyz789",
 *   "sku": "JACKET-BLK-L",
 *   "price": 14999,
 *   "stock": 50,
 *   "isActive": true,
 *   "product": {...},
 *   "images": [],
 *   "facets": []
 * }
 */


================================================================================
FILE: app/api/webhooks/[provider]/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { headers } from 'next/headers';
import { handleStripeWebhook } from '@/lib/payments/stripe';
import { handleRazorpayWebhook } from '@/lib/payments/razorpay';

/**
 * POST /api/webhooks/stripe
 * POST /api/webhooks/razorpay
 * 
 * Handle payment provider webhooks
 * Note: Webhook URLs must include storeId in query params
 * Example: /api/webhooks/stripe?storeId=store_123
 */
export async function POST(
  req: NextRequest,
  { params }: { params: { provider: string } }
) {
  try {
    const { searchParams } = new URL(req.url);
    const storeId = searchParams.get('storeId');

    if (!storeId) {
      return NextResponse.json(
        { error: 'storeId query parameter is required' },
        { status: 400 }
      );
    }

    const provider = params.provider.toLowerCase();

    switch (provider) {
      case 'stripe': {
        const headersList = await headers();
        const signature = headersList.get('stripe-signature');

        if (!signature) {
          return NextResponse.json(
            { error: 'Missing stripe-signature header' },
            { status: 400 }
          );
        }

        const body = await req.text();

        const result = await handleStripeWebhook(storeId, body, signature);
        return NextResponse.json(result);
      }

      case 'razorpay': {
        const headersList = await headers();
        const signature = headersList.get('x-razorpay-signature');

        if (!signature) {
          return NextResponse.json(
            { error: 'Missing x-razorpay-signature header' },
            { status: 400 }
          );
        }

        const body = await req.json();

        const result = await handleRazorpayWebhook(storeId, body, signature);
        return NextResponse.json(result);
      }

      default:
        return NextResponse.json(
          { error: 'Unsupported payment provider' },
          { status: 400 }
        );
    }
  } catch (error: any) {
    console.error(`Webhook error (${params.provider}):`, error);
    return NextResponse.json(
      { error: error.message || 'Webhook processing failed' },
      { status: 400 }
    );
  }
}

/**
 * Webhook URL Setup:
 * 
 * Stripe:
 * - URL: https://your-domain.com/api/webhooks/stripe?storeId=store_123
 * - Events to listen: payment_intent.succeeded, payment_intent.payment_failed, charge.refunded
 * 
 * Razorpay:
 * - URL: https://your-domain.com/api/webhooks/razorpay?storeId=store_123
 * - Events to listen: payment.captured, payment.failed
 * 
 * IMPORTANT: Each store must have its own webhook URL with unique storeId
 */


END OF EXPORT
